{
  "version": 3,
  "sources": ["../../ripple/src/runtime/internal/client/constants.js", "../../ripple/src/runtime/internal/client/utils.js", "../../ripple/src/runtime/internal/client/operations.js", "../../ripple/src/utils/events.js", "../../esm-env/true.js", "../../ripple/src/runtime/internal/client/runtime.js", "../../ripple/src/runtime/internal/client/events.js", "../../ripple/src/runtime/internal/client/blocks.js", "../../ripple/src/runtime/internal/client/css.js", "../../ripple/src/jsx-runtime.js", "../../ripple/src/runtime/internal/client/context.js", "../../ripple/src/runtime/proxy.js", "../../ripple/src/runtime/array.js", "../../ripple/src/runtime/object.js", "../../ripple/src/runtime/set.js", "../../ripple/src/runtime/map.js", "../../ripple/src/runtime/date.js", "../../ripple/src/runtime/url-search-params.js", "../../ripple/src/runtime/url.js", "../../ripple/src/runtime/create-subscriber.js", "../../ripple/src/constants.js", "../../devalue/src/utils.js", "../../ripple/src/runtime/reactive-value.js", "../../ripple/src/runtime/media-query.js", "../../ripple/src/runtime/internal/client/portal.js", "../../ripple/src/runtime/internal/client/bindings.js", "../../ripple/src/runtime/index-client.js"],
  "sourcesContent": ["export var ROOT_BLOCK = 1 << 1;\nexport var RENDER_BLOCK = 1 << 2;\nexport var EFFECT_BLOCK = 1 << 3;\nexport var BRANCH_BLOCK = 1 << 4;\nexport var FOR_BLOCK = 1 << 5;\nexport var TRY_BLOCK = 1 << 6;\nexport var IF_BLOCK = 1 << 7;\nexport var SWITCH_BLOCK = 1 << 8;\nexport var COMPOSITE_BLOCK = 1 << 9;\nexport var ASYNC_BLOCK = 1 << 10;\nexport var HEAD_BLOCK = 1 << 11;\nexport var CONTAINS_UPDATE = 1 << 12;\nexport var CONTAINS_TEARDOWN = 1 << 13;\nexport var BLOCK_HAS_RUN = 1 << 14;\nexport var TRACKED = 1 << 15;\nexport var DERIVED = 1 << 16;\nexport var DEFERRED = 1 << 17;\nexport var PAUSED = 1 << 18;\nexport var DESTROYED = 1 << 19;\n\nexport var CONTROL_FLOW_BLOCK = FOR_BLOCK | IF_BLOCK | SWITCH_BLOCK | TRY_BLOCK | COMPOSITE_BLOCK;\n\nexport var UNINITIALIZED = Symbol();\n/** @type {unique symbol} */\nexport const TRACKED_ARRAY = Symbol();\n/** @type {unique symbol} */\nexport const TRACKED_OBJECT = Symbol();\nexport var COMPUTED_PROPERTY = Symbol();\nexport var REF_PROP = 'ref';\n/** @type {unique symbol} */\nexport const ARRAY_SET_INDEX_AT = Symbol();\nexport const MAX_ARRAY_LENGTH = 2 ** 32 - 1;\nexport const DEFAULT_NAMESPACE = 'html';\nexport const NAMESPACE_URI = {\n\thtml: 'http://www.w3.org/1999/xhtml',\n\tsvg: 'http://www.w3.org/2000/svg',\n\tmathml: 'http://www.w3.org/1998/Math/MathML',\n};\n", "/** @import { NAMESPACE_URI } from './constants.js' */\n\n/** @type {typeof Object.getOwnPropertyDescriptor} */\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\n/** @type {typeof Object.getOwnPropertyDescriptors} */\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\n/** @type {typeof Array.from} */\nexport var array_from = Array.from;\n/** @type {typeof Array.isArray} */\nexport var is_array = Array.isArray;\n/** @type {typeof Object.defineProperty} */\nexport var define_property = Object.defineProperty;\n/** @type {typeof Object.getPrototypeOf} */\nexport var get_prototype_of = Object.getPrototypeOf;\n/** @type {typeof Object.values} */\nexport var object_values = Object.values;\n/** @type {typeof Object.entries} */\nexport var object_entries = Object.entries;\n/** @type {typeof Object.keys} */\nexport var object_keys = Object.keys;\n/** @type {typeof Object.getOwnPropertySymbols} */\nexport var get_own_property_symbols = Object.getOwnPropertySymbols;\n/** @type {typeof structuredClone} */\nexport var structured_clone = structuredClone;\n/** @type {typeof Object.prototype} */\nexport var object_prototype = Object.prototype;\n/** @type {typeof Array.prototype} */\nexport var array_prototype = Array.prototype;\n\n/**\n * Creates a text node that serves as an anchor point in the DOM.\n * @returns {Text}\n */\nexport function create_anchor() {\n\tvar t = document.createTextNode('');\n\t/** @type {any} */ (t).__t = '';\n\treturn t;\n}\n\n/**\n * Checks if an object is a tracked object (has a numeric 'f' property).\n * @param {any} v - The object to check.\n * @returns {boolean}\n */\nexport function is_tracked_object(v) {\n\treturn typeof v === 'object' && v !== null && typeof (/** @type {any} */ (v).f) === 'number';\n}\n\n/**\n * Converts a tag name to its corresponding namespace.\n * @param {keyof SVGElementTagNameMap | keyof MathMLElementTagNameMap | keyof HTMLElementTagNameMap} element\n * @param {keyof typeof NAMESPACE_URI} current_namespace\n * @returns {keyof typeof NAMESPACE_URI}\n */\nexport function top_element_to_ns(element, current_namespace) {\n\tif (element === 'svg') {\n\t\treturn 'svg';\n\t} else if (element === 'math') {\n\t\treturn 'mathml';\n\t} else {\n\t\treturn current_namespace;\n\t}\n}\n", "import { get_descriptor } from './utils.js';\n\n/** @type {() => Node | null} */\nvar first_child_getter;\n/** @type {() => Node | null} */\nvar next_sibling_getter;\n\n/** @type {Document} */\nexport var document;\n\n/** @type {boolean} */\nexport var is_firefox;\n\nexport function init_operations() {\n\tvar node_prototype = Node.prototype;\n\tvar element_prototype = Element.prototype;\n\tvar event_target_prototype = EventTarget.prototype;\n\n\tis_firefox = /Firefox/.test(navigator.userAgent);\n\tdocument = window.document;\n\n\t// @ts-ignore\n\tfirst_child_getter = get_descriptor(node_prototype, 'firstChild').get;\n\t// @ts-ignore\n\tnext_sibling_getter = get_descriptor(node_prototype, 'nextSibling').get;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\tevent_target_prototype.__root = undefined;\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\nexport function first_child(node) {\n\treturn first_child_getter.call(node);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\nexport function child_frag(node) {\n\tvar child = /** @type {Text} */ (first_child(node));\n\n\tif (child.nodeType === 8 && child.data === '') {\n\t\treturn next_sibling(child);\n\t}\n\treturn child;\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*@__NO_SIDE_EFFECTS__*/\nexport function next_sibling(node) {\n\treturn next_sibling_getter.call(node);\n}\n\nexport function create_text(value = '') {\n\treturn document.createTextNode(value);\n}\n", "/** List of Element events that will be delegated */\nconst DELEGATED_EVENTS = [\n  'beforeinput',\n  'click',\n  'change',\n  'dblclick',\n  'contextmenu',\n  'focusin',\n  'focusout',\n  'input',\n  'keydown',\n  'keyup',\n  'mousedown',\n  'mousemove',\n  'mouseout',\n  'mouseover',\n  'mouseup',\n  'pointerdown',\n  'pointermove',\n  'pointerout',\n  'pointerover',\n  'pointerup',\n  'touchend',\n  'touchmove',\n  'touchstart',\n];\n\n/**\n * Checks if an event should be delegated\n * @param {string} event_name - The event name (e.g., 'click', 'focus')\n * @returns {boolean}\n */\nexport function is_delegated(event_name) {\n  return DELEGATED_EVENTS.includes(event_name);\n}\n\n/**\n * Determines if an attribute is an event attribute (e.g., 'onClick').\n * @param {string} attr - The attribute name.\n * @returns {boolean}\n */\nexport function is_event_attribute(attr) {\n  return attr.startsWith('on') && attr.length > 2 && attr[2] === attr[2].toUpperCase();\n}\n\n/**\n * @param {string} name\n */\nexport function is_capture_event(name) {\n  return (\n    name.endsWith('Capture') &&\n    name.toLowerCase() !== 'gotpointercapture' &&\n    name.toLowerCase() !== 'lostpointercapture'\n  );\n}\n\n/**\n * @param {string} event_name\n */\nexport function get_attribute_event_name(event_name) {\n  event_name = event_name.slice(2); // strip \"on\"\n  if (is_capture_event(event_name)) {\n    event_name = event_name.slice(0, -7); // strip \"Capture\"\n  }\n  return event_name.toLowerCase();\n}\n\nconst PASSIVE_EVENTS = ['touchstart', 'touchmove'];\n\n/**\n * Checks if an event is passive (e.g., 'touchstart', 'touchmove').\n * @param {string} name - The event name.\n * @returns {boolean}\n */\nexport function is_passive_event(name) {\n  return PASSIVE_EVENTS.includes(name);\n}\n", "export default true;\n", "/** @import { Block, Component, Dependency, Derived, Tracked } from '#client' */\n/** @import { NAMESPACE_URI } from './constants.js' */\n\nimport { DEV } from 'esm-env';\nimport {\n\tdestroy_block,\n\tdestroy_non_branch_children,\n\teffect,\n\tis_destroyed,\n\trender,\n} from './blocks.js';\nimport {\n\tASYNC_BLOCK,\n\tBLOCK_HAS_RUN,\n\tBRANCH_BLOCK,\n\tDERIVED,\n\tCOMPUTED_PROPERTY,\n\tCONTAINS_TEARDOWN,\n\tCONTAINS_UPDATE,\n\tDEFERRED,\n\tDESTROYED,\n\tEFFECT_BLOCK,\n\tPAUSED,\n\tROOT_BLOCK,\n\tTRACKED,\n\tTRY_BLOCK,\n\tUNINITIALIZED,\n\tREF_PROP,\n\tTRACKED_OBJECT,\n\tDEFAULT_NAMESPACE,\n} from './constants.js';\nimport { capture, suspend } from './try.js';\nimport {\n\tdefine_property,\n\tget_descriptor,\n\tget_own_property_symbols,\n\tis_array,\n\tis_tracked_object,\n\tobject_keys,\n} from './utils.js';\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\n/** @type {null | Block} */\nexport let active_block = null;\n/** @type {null | Block | Derived} */\nexport let active_reaction = null;\n/** @type {null | Block} */\nexport let active_scope = null;\n/** @type {null | Component} */\nexport let active_component = null;\n/** @type {keyof typeof NAMESPACE_URI} */\nexport let active_namespace = DEFAULT_NAMESPACE;\n/** @type {boolean} */\nexport let is_mutating_allowed = true;\n\n/** @type {Map<Tracked, any>} */\nvar old_values = new Map();\n\n// Used for controlling the flush of blocks\n/** @type {number} */\nlet scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\n/** @type {boolean} */\nlet is_micro_task_queued = false;\n/** @type {number} */\nlet clock = 0;\n/** @type {Block[]} */\nlet queued_root_blocks = [];\n/** @type {(() => void)[]} */\nlet queued_microtasks = [];\n/** @type {number} */\nlet flush_count = 0;\n/** @type {null | Dependency} */\nlet active_dependency = null;\n\nexport let tracking = false;\nexport let teardown = false;\n\n/**\n * @returns {number}\n */\nfunction increment_clock() {\n\treturn ++clock;\n}\n\n/**\n * @param {Block | null} block\n */\nexport function set_active_block(block) {\n\tactive_block = block;\n}\n\n/**\n * @param {Block | Derived | null} reaction\n */\nexport function set_active_reaction(reaction) {\n\tactive_reaction = reaction;\n}\n\n/**\n * @param {Component | null} component\n */\nexport function set_active_component(component) {\n\tactive_component = component;\n}\n\n/**\n * @param {boolean} value\n */\nexport function set_tracking(value) {\n\ttracking = value;\n}\n\n/**\n * @param {Block} block\n */\nexport function run_teardown(block) {\n\tvar fn = block.t;\n\tif (fn !== null) {\n\t\tvar previous_block = active_block;\n\t\tvar previous_reaction = active_reaction;\n\t\tvar previous_tracking = tracking;\n\t\tvar previous_teardown = teardown;\n\n\t\ttry {\n\t\t\tactive_block = null;\n\t\t\tactive_reaction = null;\n\t\t\ttracking = false;\n\t\t\tteardown = true;\n\t\t\tfn.call(null);\n\t\t} finally {\n\t\t\tactive_block = previous_block;\n\t\t\tactive_reaction = previous_reaction;\n\t\t\ttracking = previous_tracking;\n\t\t\tteardown = previous_teardown;\n\t\t}\n\t}\n}\n\n/**\n * @param {Block} block\n * @param {() => void} fn\n */\nexport function with_block(block, fn) {\n\tvar prev_block = active_block;\n\tvar previous_component = active_component;\n\tactive_block = block;\n\tactive_component = block.co;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tactive_component = previous_component;\n\t\tactive_block = prev_block;\n\t}\n}\n\n/**\n * @param {Derived} computed\n */\nfunction update_derived(computed) {\n\tvar value = computed.__v;\n\n\tif (value === UNINITIALIZED || is_tracking_dirty(computed.d)) {\n\t\tvalue = run_derived(computed);\n\n\t\tif (value !== computed.__v) {\n\t\t\tcomputed.__v = value;\n\t\t\tcomputed.c = increment_clock();\n\t\t}\n\t}\n}\n\n/**\n * @param {Derived} computed\n */\nfunction destroy_computed_children(computed) {\n\tvar blocks = computed.blocks;\n\n\tif (blocks !== null) {\n\t\tcomputed.blocks = null;\n\t\tfor (var i = 0; i < blocks.length; i++) {\n\t\t\tdestroy_block(blocks[i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {Derived} computed\n */\nfunction run_derived(computed) {\n\tvar previous_block = active_block;\n\tvar previous_reaction = active_reaction;\n\tvar previous_tracking = tracking;\n\tvar previous_dependency = active_dependency;\n\tvar previous_component = active_component;\n\tvar previous_is_mutating_allowed = is_mutating_allowed;\n\n\ttry {\n\t\tactive_block = computed.b;\n\t\tactive_reaction = computed;\n\t\ttracking = true;\n\t\tactive_dependency = null;\n\t\tactive_component = computed.co;\n\t\tis_mutating_allowed = false;\n\n\t\tdestroy_computed_children(computed);\n\n\t\tvar value = computed.fn();\n\n\t\tcomputed.d = active_dependency;\n\n\t\treturn value;\n\t} finally {\n\t\tactive_block = previous_block;\n\t\tactive_reaction = previous_reaction;\n\t\ttracking = previous_tracking;\n\t\tactive_dependency = previous_dependency;\n\t\tactive_component = previous_component;\n\t\tis_mutating_allowed = previous_is_mutating_allowed;\n\t}\n}\n\n/**\n * @param {unknown} error\n * @param {Block} block\n */\nexport function handle_error(error, block) {\n\t/** @type {Block | null} */\n\tvar current = block;\n\n\twhile (current !== null) {\n\t\tvar state = current.s;\n\t\tif ((current.f & TRY_BLOCK) !== 0 && state.c !== null) {\n\t\t\tstate.c(error);\n\t\t\treturn;\n\t\t}\n\t\tcurrent = current.p;\n\t}\n\n\tthrow error;\n}\n\n/**\n * @param {Block} block\n */\nexport function run_block(block) {\n\tvar previous_block = active_block;\n\tvar previous_reaction = active_reaction;\n\tvar previous_tracking = tracking;\n\tvar previous_dependency = active_dependency;\n\tvar previous_component = active_component;\n\n\ttry {\n\t\tactive_block = block;\n\t\tactive_reaction = block;\n\t\tactive_component = block.co;\n\n\t\tdestroy_non_branch_children(block);\n\t\trun_teardown(block);\n\n\t\ttracking = (block.f & (ROOT_BLOCK | BRANCH_BLOCK)) === 0;\n\t\tactive_dependency = null;\n\t\tvar res = block.fn(block.s);\n\n\t\tif (typeof res === 'function') {\n\t\t\tblock.t = res;\n\t\t\t/** @type {Block | null} */\n\t\t\tlet current = block;\n\n\t\t\twhile (current !== null && (current.f & CONTAINS_TEARDOWN) === 0) {\n\t\t\t\tcurrent.f ^= CONTAINS_TEARDOWN;\n\t\t\t\tcurrent = current.p;\n\t\t\t}\n\t\t}\n\n\t\tblock.d = active_dependency;\n\t} catch (error) {\n\t\thandle_error(error, block);\n\t} finally {\n\t\tactive_block = previous_block;\n\t\tactive_reaction = previous_reaction;\n\t\ttracking = previous_tracking;\n\t\tactive_dependency = previous_dependency;\n\t\tactive_component = previous_component;\n\t}\n}\n\nvar empty_get_set = { get: undefined, set: undefined };\n\n/**\n *\n * @param {any} v\n * @param {Block} block\n * @param {(value: any) => any} [get]\n * @param {(next: any, prev: any) => any} [set]\n * @returns {Tracked}\n */\nexport function tracked(v, block, get, set) {\n\t// TODO: now we expose tracked, we should likely block access in DEV somehow\n\tif (DEV) {\n\t\treturn {\n\t\t\tDO_NOT_ACCESS_THIS_OBJECT_DIRECTLY: true,\n\t\t\ta: get || set ? { get, set } : empty_get_set,\n\t\t\tb: block || active_block,\n\t\t\tc: 0,\n\t\t\tf: TRACKED,\n\t\t\t__v: v,\n\t\t};\n\t}\n\n\treturn {\n\t\ta: get || set ? { get, set } : empty_get_set,\n\t\tb: block || active_block,\n\t\tc: 0,\n\t\tf: TRACKED,\n\t\t__v: v,\n\t};\n}\n\n/**\n * @param {any} fn\n * @param {any} block\n * @param {(value: any) => any} [get]\n * @param {(next: any, prev: any) => any} [set]\n * @returns {Derived}\n */\nexport function derived(fn, block, get, set) {\n\tif (DEV) {\n\t\treturn {\n\t\t\tDO_NOT_ACCESS_THIS_OBJECT_DIRECTLY: true,\n\t\t\ta: get || set ? { get, set } : empty_get_set,\n\t\t\tb: block || active_block,\n\t\t\tblocks: null,\n\t\t\tc: 0,\n\t\t\tco: active_component,\n\t\t\td: null,\n\t\t\tf: TRACKED | DERIVED,\n\t\t\tfn,\n\t\t\t__v: UNINITIALIZED,\n\t\t};\n\t}\n\n\treturn {\n\t\ta: get || set ? { get, set } : empty_get_set,\n\t\tb: block || active_block,\n\t\tblocks: null,\n\t\tc: 0,\n\t\tco: active_component,\n\t\td: null,\n\t\tf: TRACKED | DERIVED,\n\t\tfn,\n\t\t__v: UNINITIALIZED,\n\t};\n}\n\n/**\n * @param {any} v\n * @param {(value: any) => any | undefined} get\n * @param {(next: any, prev: any) => any | undefined} set\n * @param {Block} b\n * @returns {Tracked | Derived}\n */\nexport function track(v, get, set, b) {\n\tif (is_tracked_object(v)) {\n\t\treturn v;\n\t}\n\tif (b === null) {\n\t\tthrow new TypeError('track() requires a valid component context');\n\t}\n\n\tif (typeof v === 'function') {\n\t\treturn derived(v, b, get, set);\n\t}\n\treturn tracked(v, b, get, set);\n}\n\n/**\n * @param {Record<string|symbol, any>} v\n * @param {(symbol | string)[]} l\n * @param {Block} b\n * @returns {Tracked[]}\n */\nexport function track_split(v, l, b) {\n\tvar is_tracked = is_tracked_object(v);\n\n\tif (is_tracked || typeof v !== 'object' || v === null || is_array(v)) {\n\t\tthrow new TypeError('Invalid value: expected a non-tracked object');\n\t}\n\n\t/** @type {Tracked[]} */\n\tvar out = [];\n\t/** @type {Record<string|symbol, any>} */\n\tvar rest = {};\n\t/** @type {Record<PropertyKey, 1>} */\n\tvar done = {};\n\tvar props = Reflect.ownKeys(v);\n\n\tfor (let i = 0, key, t; i < l.length; i++) {\n\t\tkey = l[i];\n\n\t\tif (props.includes(key)) {\n\t\t\tif (is_tracked_object(v[key])) {\n\t\t\t\tt = v[key];\n\t\t\t} else {\n\t\t\t\tt = tracked(undefined, b);\n\t\t\t\tt = define_property(t, '__v', /** @type {PropertyDescriptor} */ (get_descriptor(v, key)));\n\t\t\t}\n\t\t} else {\n\t\t\tt = tracked(undefined, b);\n\t\t}\n\n\t\tout[i] = t;\n\t\tdone[key] = 1;\n\t}\n\n\tfor (let i = 0, key; i < props.length; i++) {\n\t\tkey = props[i];\n\t\tif (done[key]) {\n\t\t\tcontinue;\n\t\t}\n\t\tdefine_property(rest, key, /** @type {PropertyDescriptor} */ (get_descriptor(v, key)));\n\t}\n\n\tout.push(tracked(rest, b));\n\n\treturn out;\n}\n\n/**\n * @param {Tracked} tracked\n * @returns {Dependency}\n */\nfunction create_dependency(tracked) {\n\tvar reaction = /** @type {Derived | Block} **/ (active_reaction);\n\tvar existing = reaction.d;\n\n\t// Recycle tracking entries\n\tif (existing !== null) {\n\t\treaction.d = existing.n;\n\t\texisting.c = tracked.c;\n\t\texisting.t = tracked;\n\t\texisting.n = null;\n\t\treturn existing;\n\t}\n\n\treturn {\n\t\tc: tracked.c,\n\t\tt: tracked,\n\t\tn: null,\n\t};\n}\n\n/**\n * @param {Dependency | null} tracking\n */\nfunction is_tracking_dirty(tracking) {\n\tif (tracking === null) {\n\t\treturn false;\n\t}\n\twhile (tracking !== null) {\n\t\tvar tracked = tracking.t;\n\n\t\tif ((tracked.f & DERIVED) !== 0) {\n\t\t\tupdate_derived(/** @type {Derived} **/ (tracked));\n\t\t}\n\n\t\tif (tracked.c > tracking.c) {\n\t\t\treturn true;\n\t\t}\n\t\ttracking = tracking.n;\n\t}\n\n\treturn false;\n}\n\n/**\n * @param {Block} block\n */\nexport function is_block_dirty(block) {\n\tvar flags = block.f;\n\n\tif ((flags & (ROOT_BLOCK | BRANCH_BLOCK)) !== 0) {\n\t\treturn false;\n\t}\n\tif ((flags & BLOCK_HAS_RUN) === 0) {\n\t\tblock.f ^= BLOCK_HAS_RUN;\n\t\treturn true;\n\t}\n\n\treturn is_tracking_dirty(block.d);\n}\n\n/**\n * @param {() => Promise<any>} fn\n * @param {Block} block\n * @returns {Promise<Tracked>}\n */\nexport function async_computed(fn, block) {\n\t/** @type {Block | Derived | null} */\n\tlet parent = active_reaction;\n\tvar t = tracked(UNINITIALIZED, block);\n\t/** @type {Promise<any>} */\n\tvar promise;\n\t/** @type {Map<Tracked, {v: any, c: number}>} */\n\tvar new_values = new Map();\n\n\trender(\n\t\t() => {\n\t\t\tvar [current, deferred] = capture_deferred(() => (promise = fn()));\n\n\t\t\tvar restore = capture();\n\t\t\t/** @type {(() => void) | undefined} */\n\t\t\tvar unuspend;\n\n\t\t\tif (deferred === null) {\n\t\t\t\tunuspend = suspend();\n\t\t\t} else {\n\t\t\t\tfor (var i = 0; i < deferred.length; i++) {\n\t\t\t\t\tvar tracked = deferred[i];\n\t\t\t\t\tnew_values.set(tracked, { v: tracked.__v, c: tracked.c });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tpromise.then((v) => {\n\t\t\t\tif (parent && is_destroyed(/** @type {Block} */ (parent))) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (promise === current && t.__v !== v) {\n\t\t\t\t\trestore();\n\n\t\t\t\t\tif (t.__v === UNINITIALIZED) {\n\t\t\t\t\t\tt.__v = v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tset(t, v);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (deferred === null) {\n\t\t\t\t\tunuspend?.();\n\t\t\t\t} else if (promise === current) {\n\t\t\t\t\tfor (var i = 0; i < deferred.length; i++) {\n\t\t\t\t\t\tvar tracked = deferred[i];\n\t\t\t\t\t\tvar stored = /** @type {{ v: any, c: number }} */ (new_values.get(tracked));\n\t\t\t\t\t\tvar { v, c } = stored;\n\t\t\t\t\t\ttracked.__v = v;\n\t\t\t\t\t\ttracked.c = c;\n\t\t\t\t\t\tschedule_update(tracked.b);\n\t\t\t\t\t}\n\t\t\t\t\tnew_values.clear();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\t\tnull,\n\t\tASYNC_BLOCK,\n\t);\n\n\treturn new Promise(async (resolve) => {\n\t\tvar p;\n\t\twhile (p !== (p = promise)) await p;\n\t\treturn resolve(t);\n\t});\n}\n\n/**\n * @template V\n * @param {Function} fn\n * @param {V} v\n */\nfunction trigger_track_get(fn, v) {\n\tvar previous_is_mutating_allowed = is_mutating_allowed;\n\ttry {\n\t\tis_mutating_allowed = false;\n\t\treturn untrack(() => fn(v));\n\t} finally {\n\t\tis_mutating_allowed = previous_is_mutating_allowed;\n\t}\n}\n\n/**\n * @param {() => any} fn\n * @returns {[any, Tracked[] | null]}\n */\nfunction capture_deferred(fn) {\n\tvar value = fn();\n\t/** @type {Tracked[] | null} */\n\tvar deferred = null;\n\tvar depedency = active_dependency;\n\n\twhile (depedency !== null) {\n\t\tvar tracked = depedency.t;\n\t\tif ((tracked.f & DEFERRED) !== 0) {\n\t\t\tdeferred ??= [];\n\t\t\tdeferred.push(tracked);\n\t\t\tbreak;\n\t\t}\n\t\tdepedency = depedency.n;\n\t}\n\n\treturn [value, deferred];\n}\n\n/**\n * @param {Block} root_block\n */\nfunction flush_updates(root_block) {\n\t/** @type {Block | null} */\n\tvar current = root_block;\n\tvar containing_update = null;\n\tvar effects = [];\n\n\twhile (current !== null) {\n\t\tvar flags = current.f;\n\n\t\tif ((flags & CONTAINS_UPDATE) !== 0) {\n\t\t\tcurrent.f ^= CONTAINS_UPDATE;\n\t\t\tcontaining_update = current;\n\t\t}\n\n\t\tif ((flags & PAUSED) === 0 && containing_update !== null) {\n\t\t\tif ((flags & EFFECT_BLOCK) !== 0) {\n\t\t\t\teffects.push(current);\n\t\t\t} else {\n\t\t\t\ttry {\n\t\t\t\t\tif (is_block_dirty(current)) {\n\t\t\t\t\t\trun_block(current);\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\thandle_error(error, current);\n\t\t\t\t}\n\t\t\t}\n\t\t\t/** @type {Block | null} */\n\t\t\tvar child = current.first;\n\n\t\t\tif (child !== null) {\n\t\t\t\tcurrent = child;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\t/** @type {Block | null} */\n\t\tvar parent = current.p;\n\t\tcurrent = current.next;\n\n\t\twhile (current === null && parent !== null) {\n\t\t\tif (parent === containing_update) {\n\t\t\t\tcontaining_update = null;\n\t\t\t}\n\t\t\tcurrent = parent.next;\n\t\t\tparent = parent.p;\n\t\t}\n\t}\n\n\tvar length = effects.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar effect = effects[i];\n\t\tvar flags = effect.f;\n\n\t\ttry {\n\t\t\tif ((flags & (PAUSED | DESTROYED)) === 0 && is_block_dirty(effect)) {\n\t\t\t\trun_block(effect);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\thandle_error(error, effect);\n\t\t}\n\t}\n}\n\n/**\n * @param {Block[]} root_blocks\n */\nfunction flush_queued_root_blocks(root_blocks) {\n\tfor (let i = 0; i < root_blocks.length; i++) {\n\t\tflush_updates(root_blocks[i]);\n\t}\n}\n\n/**\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\treturn new Promise((f) => requestAnimationFrame(() => f()));\n}\n\n/**\n * @returns {void}\n */\nfunction flush_microtasks() {\n\tis_micro_task_queued = false;\n\n\tif (queued_microtasks.length > 0) {\n\t\tvar microtasks = queued_microtasks;\n\t\tqueued_microtasks = [];\n\t\tfor (var i = 0; i < microtasks.length; i++) {\n\t\t\tmicrotasks[i]();\n\t\t}\n\t}\n\n\tif (flush_count > 1001) {\n\t\treturn;\n\t}\n\tvar previous_queued_root_blocks = queued_root_blocks;\n\tqueued_root_blocks = [];\n\tflush_queued_root_blocks(previous_queued_root_blocks);\n\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t}\n\told_values.clear();\n}\n\n/**\n * @param { (() => void) } [fn]\n */\nexport function queue_microtask(fn) {\n\tif (!is_micro_task_queued) {\n\t\tis_micro_task_queued = true;\n\t\tqueueMicrotask(flush_microtasks);\n\t}\n\tif (fn !== undefined) {\n\t\tqueued_microtasks.push(fn);\n\t}\n}\n\n/**\n * @param {Block} block\n */\nexport function schedule_update(block) {\n\tif (scheduler_mode === FLUSH_MICROTASK) {\n\t\tqueue_microtask();\n\t}\n\tlet current = block;\n\n\twhile (current !== null) {\n\t\tvar flags = current.f;\n\t\tif ((flags & CONTAINS_UPDATE) !== 0) return;\n\t\tcurrent.f ^= CONTAINS_UPDATE;\n\t\tif ((flags & ROOT_BLOCK) !== 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcurrent = /** @type {Block} */ (current.p);\n\t}\n\n\tqueued_root_blocks.push(current);\n}\n\n/**\n * @param {Tracked} tracked\n */\nfunction register_dependency(tracked) {\n\tvar dependency = active_dependency;\n\n\tif (dependency === null) {\n\t\tdependency = create_dependency(tracked);\n\t\tactive_dependency = dependency;\n\t} else {\n\t\tvar current = dependency;\n\n\t\twhile (current !== null) {\n\t\t\tif (current.t === tracked) {\n\t\t\t\tcurrent.c = tracked.c;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar next = current.n;\n\t\t\tif (next === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent = next;\n\t\t}\n\n\t\tdependency = create_dependency(tracked);\n\t\tcurrent.n = dependency;\n\t}\n}\n\n/**\n * @param {Derived} computed\n */\nexport function get_derived(computed) {\n\tupdate_derived(computed);\n\tif (tracking) {\n\t\tregister_dependency(computed);\n\t}\n\tvar get = computed.a.get;\n\tif (get !== undefined) {\n\t\tcomputed.__v = trigger_track_get(get, computed.__v);\n\t}\n\n\treturn computed.__v;\n}\n\n/**\n * @param {Derived | Tracked} tracked\n */\nexport function get(tracked) {\n\t// reflect back the value if it's not boxed\n\tif (!is_tracked_object(tracked)) {\n\t\treturn tracked;\n\t}\n\n\treturn (tracked.f & DERIVED) !== 0\n\t\t? get_derived(/** @type {Derived} */ (tracked))\n\t\t: get_tracked(tracked);\n}\n\n/**\n * @param {Tracked} tracked\n */\nexport function get_tracked(tracked) {\n\tvar value = tracked.__v;\n\tif (tracking) {\n\t\tregister_dependency(tracked);\n\t}\n\tif (teardown && old_values.has(tracked)) {\n\t\tvalue = old_values.get(tracked);\n\t}\n\tvar get = tracked.a.get;\n\tif (get !== undefined) {\n\t\tvalue = trigger_track_get(get, value);\n\t}\n\treturn value;\n}\n\n/**\n * Exposed version of `set` to avoid internal bugs\n * since block is required on the internal `set`\n * @param {Derived | Tracked} tracked\n * @param {any} value\n */\nexport function public_set(tracked, value) {\n\tset(tracked, value);\n}\n\n/**\n * @param {Derived | Tracked} tracked\n * @param {any} value\n */\nexport function set(tracked, value) {\n\tif (!is_mutating_allowed) {\n\t\tthrow new Error(\n\t\t\t'Assignments or updates to tracked values are not allowed during computed \"track(() => ...)\" evaluation',\n\t\t);\n\t}\n\n\tvar old_value = tracked.__v;\n\n\tif (value !== old_value) {\n\t\tvar tracked_block = tracked.b;\n\n\t\tif ((tracked_block.f & CONTAINS_TEARDOWN) !== 0) {\n\t\t\tif (teardown) {\n\t\t\t\told_values.set(tracked, value);\n\t\t\t} else {\n\t\t\t\told_values.set(tracked, old_value);\n\t\t\t}\n\t\t}\n\n\t\tlet set = tracked.a.set;\n\t\tif (set !== undefined) {\n\t\t\tvalue = untrack(() => set(value, old_value));\n\t\t}\n\n\t\ttracked.__v = value;\n\t\ttracked.c = increment_clock();\n\t\tschedule_update(tracked_block);\n\t}\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tvar previous_tracking = tracking;\n\tvar previous_dependency = active_dependency;\n\ttracking = false;\n\tactive_dependency = null;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\ttracking = previous_tracking;\n\t\tactive_dependency = previous_dependency;\n\t}\n}\n\n/**\n * @template T\n * @param {() => T} [fn]\n * @returns {T}\n */\nexport function flush_sync(fn) {\n\tvar previous_scheduler_mode = scheduler_mode;\n\tvar previous_queued_root_blocks = queued_root_blocks;\n\n\ttry {\n\t\t/** @type {Block[]} */\n\t\tvar root_blocks = [];\n\n\t\tscheduler_mode = FLUSH_SYNC;\n\t\tqueued_root_blocks = root_blocks;\n\t\tis_micro_task_queued = false;\n\n\t\tflush_queued_root_blocks(previous_queued_root_blocks);\n\n\t\tvar result = fn?.();\n\n\t\tif (queued_root_blocks.length > 0 || root_blocks.length > 0) {\n\t\t\tflush_sync();\n\t\t}\n\n\t\tflush_count = 0;\n\n\t\treturn /** @type {T} */ (result);\n\t} finally {\n\t\tscheduler_mode = previous_scheduler_mode;\n\t\tqueued_root_blocks = previous_queued_root_blocks;\n\t}\n}\n\n/**\n * @param {() => Object} fn\n * @returns {Object}\n */\nexport function spread_props(fn) {\n\treturn proxy_props(fn);\n}\n\n/**\n * @param {() => Object} fn\n * @returns {Object}\n */\nexport function proxy_props(fn) {\n\tconst memo = derived(fn, active_block);\n\n\treturn new Proxy(\n\t\t{},\n\t\t{\n\t\t\tget(_, property) {\n\t\t\t\t/** @type {Record<string | symbol, any> | Record<string | symbol, any>[]} */\n\t\t\t\tvar obj = get_derived(memo);\n\n\t\t\t\t// Handle array of objects/spreads (for multiple props)\n\t\t\t\tif (is_array(obj)) {\n\t\t\t\t\t// Search in reverse order (right-to-left) since later props override earlier ones\n\t\t\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\t\t\tvar item;\n\t\t\t\t\tfor (var i = obj.length - 1; i >= 0; i--) {\n\t\t\t\t\t\titem = obj[i];\n\t\t\t\t\t\tif (property in item) {\n\t\t\t\t\t\t\treturn item[property];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\t// Single object case\n\t\t\t\treturn obj[property];\n\t\t\t},\n\t\t\thas(_, property) {\n\t\t\t\tif (property === TRACKED_OBJECT) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t/** @type {Record<string | symbol, any> | Record<string | symbol, any>[]} */\n\t\t\t\tvar obj = get_derived(memo);\n\n\t\t\t\t// Handle array of objects/spreads\n\t\t\t\tif (is_array(obj)) {\n\t\t\t\t\tfor (var i = obj.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (property in obj[i]) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn property in obj;\n\t\t\t},\n\t\t\tgetOwnPropertyDescriptor(_, key) {\n\t\t\t\t/** @type {Record<string | symbol, any> | Record<string | symbol, any>[]} */\n\t\t\t\tvar obj = get_derived(memo);\n\n\t\t\t\t// Handle array of objects/spreads\n\t\t\t\tif (is_array(obj)) {\n\t\t\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\t\t\tvar item;\n\t\t\t\t\tfor (var i = obj.length - 1; i >= 0; i--) {\n\t\t\t\t\t\titem = obj[i];\n\t\t\t\t\t\tif (key in item) {\n\t\t\t\t\t\t\treturn get_descriptor(item, key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tif (key in obj) {\n\t\t\t\t\treturn get_descriptor(obj, key);\n\t\t\t\t}\n\t\t\t},\n\t\t\townKeys() {\n\t\t\t\t/** @type {Record<string | symbol, any> | Record<string | symbol, any>[]} */\n\t\t\t\tvar obj = get_derived(memo);\n\t\t\t\t/** @type {Record<string | symbol, 1>} */\n\t\t\t\tvar done = {};\n\t\t\t\t/** @type {(string | symbol)[]} */\n\t\t\t\tvar keys = [];\n\n\t\t\t\t// Handle array of objects/spreads\n\t\t\t\tif (is_array(obj)) {\n\t\t\t\t\t// Collect all keys from all objects, order doesn't matter\n\t\t\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\t\t\tvar item;\n\t\t\t\t\tfor (var i = 0; i < obj.length; i++) {\n\t\t\t\t\t\titem = obj[i];\n\t\t\t\t\t\tfor (const key of Reflect.ownKeys(item)) {\n\t\t\t\t\t\t\tif (done[key]) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdone[key] = 1;\n\t\t\t\t\t\t\tkeys.push(key);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn keys;\n\t\t\t\t}\n\n\t\t\t\treturn Reflect.ownKeys(obj);\n\t\t\t},\n\t\t},\n\t);\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @returns {() => T}\n */\nexport function computed_property(fn) {\n\tdefine_property(fn, COMPUTED_PROPERTY, {\n\t\tvalue: true,\n\t\tenumerable: false,\n\t});\n\treturn fn;\n}\n\n/**\n * @param {any} obj\n * @param {string | number | symbol} property\n * @param {boolean} chain_obj\n * @param {boolean} chain_prop\n * @param {...any} args\n * @returns {any}\n */\nexport function call_property(obj, property, chain_obj, chain_prop, ...args) {\n\t// don't swallow errors if either the object or property is nullish,\n\t// respect optional chaining as provided\n\tif (!chain_obj && !chain_prop) {\n\t\treturn obj[property].call(obj, ...args);\n\t} else if (chain_obj && chain_prop) {\n\t\treturn obj?.[property]?.call(obj, ...args);\n\t} else if (chain_obj) {\n\t\treturn obj?.[property].call(obj, ...args);\n\t} else if (chain_prop) {\n\t\treturn obj[property]?.call(obj, ...args);\n\t}\n}\n\n/**\n * @param {any} obj\n * @param {string | number | symbol} property\n * @param {boolean} [chain=false]\n * @returns {any}\n */\nexport function get_property(obj, property, chain = false) {\n\tif (chain && obj == null) {\n\t\treturn undefined;\n\t}\n\tvar tracked = obj[property];\n\tif (tracked == null) {\n\t\treturn tracked;\n\t}\n\treturn get(tracked);\n}\n\n/**\n * @param {any} obj\n * @param {string | number | symbol} property\n * @param {any} value\n * @returns {void}\n */\nexport function set_property(obj, property, value) {\n\tvar tracked = obj[property];\n\tset(tracked, value);\n}\n\n/**\n * @param {Tracked} tracked\n * @param {number} [d]\n * @returns {number}\n */\nexport function update(tracked, d = 1) {\n\tvar value = get(tracked);\n\tvar result = d === 1 ? value++ : value--;\n\tset(tracked, value);\n\treturn result;\n}\n\n/**\n * @param {Tracked} tracked\n * @returns {void}\n */\nexport function increment(tracked) {\n\tset(tracked, tracked.__v + 1);\n}\n\n/**\n * @param {Tracked} tracked\n * @returns {void}\n */\nexport function decrement(tracked) {\n\tset(tracked, tracked.__v - 1);\n}\n\n/**\n * @param {Tracked} tracked\n * @param {number} [d]\n * @returns {number}\n */\nexport function update_pre(tracked, d = 1) {\n\tvar value = get(tracked);\n\tvar new_value = d === 1 ? ++value : --value;\n\tset(tracked, new_value);\n\treturn new_value;\n}\n\n/**\n * @param {any} obj\n * @param {string | number | symbol} property\n * @param {number} [d=1]\n * @returns {number}\n */\nexport function update_property(obj, property, d = 1) {\n\tvar tracked = obj[property];\n\tvar value = get(tracked);\n\tvar new_value = d === 1 ? value++ : value--;\n\tset(tracked, value);\n\treturn new_value;\n}\n\n/**\n * @param {any} obj\n * @param {string | number | symbol} property\n * @param {number} [d=1]\n * @returns {number}\n */\nexport function update_pre_property(obj, property, d = 1) {\n\tvar tracked = obj[property];\n\tvar value = get(tracked);\n\tvar new_value = d === 1 ? ++value : --value;\n\tset(tracked, new_value);\n\treturn new_value;\n}\n\n/**\n * @template T\n * @param {Block} block\n * @param {() => T} fn\n * @returns {T}\n */\nexport function with_scope(block, fn) {\n\tvar previous_scope = active_scope;\n\ttry {\n\t\tactive_scope = block;\n\t\treturn fn();\n\t} finally {\n\t\tactive_scope = previous_scope;\n\t}\n}\n\n/**\n * @returns {Block | null}\n */\nexport function scope() {\n\treturn active_scope || active_block;\n}\n\n/**\n * @param {string} [err]\n * @returns {Block | never}\n */\nexport function safe_scope(err = 'Cannot access outside of a component context') {\n\tif (active_scope === null) {\n\t\tthrow new Error(err);\n\t}\n\n\treturn /** @type {Block} */ (active_scope);\n}\n\nexport function create_component_ctx() {\n\treturn {\n\t\tc: null,\n\t\te: null,\n\t\tm: false,\n\t\tp: active_component,\n\t};\n}\n\n/**\n * @returns {void}\n */\nexport function push_component() {\n\tvar component = create_component_ctx();\n\tactive_component = component;\n}\n\n/**\n * @returns {void}\n */\nexport function pop_component() {\n\tvar component = /** @type {Component} */ (active_component);\n\tcomponent.m = true;\n\tvar effects = component.e;\n\tif (effects !== null) {\n\t\tvar length = effects.length;\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar { b: block, fn, r: reaction } = effects[i];\n\t\t\tvar previous_block = active_block;\n\t\t\tvar previous_reaction = active_reaction;\n\n\t\t\ttry {\n\t\t\t\tactive_block = block;\n\t\t\t\tactive_reaction = reaction;\n\t\t\t\teffect(fn);\n\t\t\t} finally {\n\t\t\t\tactive_block = previous_block;\n\t\t\t\tactive_reaction = previous_reaction;\n\t\t\t}\n\t\t}\n\t}\n\tactive_component = component.p;\n}\n\n/**\n * @template T\n * @param {() => T} fn\n * @param {keyof typeof NAMESPACE_URI} namespace\n * @returns {T}\n */\nexport function with_ns(namespace, fn) {\n\tvar previous_namespace = active_namespace;\n\tactive_namespace = namespace;\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tactive_namespace = previous_namespace;\n\t}\n}\n\n/**\n * @returns {symbol}\n */\nexport function ref_prop() {\n\treturn Symbol(REF_PROP);\n}\n\n/**\n * @template T\n * @param {T | undefined} value\n * @param {T} fallback\n * @returns {T}\n */\nexport function fallback(value, fallback) {\n\treturn value === undefined ? fallback : value;\n}\n\n/**\n * @param {Record<string | symbol, unknown>} obj\n * @param {string[]} exclude_keys\n * @returns {Record<string | symbol, unknown>}\n */\nexport function exclude_from_object(obj, exclude_keys) {\n\tvar keys = object_keys(obj);\n\t/** @type {Record<string | symbol, unknown>} */\n\tvar new_obj = {};\n\n\tfor (const key of keys) {\n\t\tif (!exclude_keys.includes(key)) {\n\t\t\tnew_obj[key] = obj[key];\n\t\t}\n\t}\n\n\tfor (const symbol of get_own_property_symbols(obj)) {\n\t\tvar ref_fn = obj[symbol];\n\n\t\tif (symbol.description === REF_PROP) {\n\t\t\tnew_obj[symbol] = ref_fn;\n\t\t}\n\t}\n\n\treturn new_obj;\n}\n\n/**\n * @param {any} v\n * @returns {Promise<() => any>}\n */\nexport async function maybe_tracked(v) {\n\tvar restore = capture();\n\tlet value;\n\n\tif (is_tracked_object(v)) {\n\t\tif ((v.f & DERIVED) !== 0) {\n\t\t\tvalue = await async_computed(v.fn, v.b);\n\t\t} else {\n\t\t\tvalue = await async_computed(async () => {\n\t\t\t\treturn await get_tracked(v);\n\t\t\t}, /** @type {Block} */ (active_block));\n\t\t}\n\t} else {\n\t\tvalue = await v;\n\t}\n\n\treturn () => {\n\t\trestore();\n\t\treturn value;\n\t};\n}\n", "import { is_passive_event } from '../../../utils/events.js';\nimport {\n\tactive_block,\n\tactive_reaction,\n\tset_active_block,\n\tset_active_reaction,\n\tset_tracking,\n\ttracking,\n} from './runtime.js';\nimport { array_from, define_property, is_array } from './utils.js';\n\n/** @type {Set<string>} */\nvar all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nvar root_event_handles = new Set();\n\n/**\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type.toLowerCase(), element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\nlet last_propagated_event = null;\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\tlast_propagated_event = event;\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = last_propagated_event === event && event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t},\n\t});\n\n\tvar previous_block = active_block;\n\tvar previous_reaction = active_reaction;\n\tvar previous_tracking = tracking;\n\n\tset_active_block(null);\n\tset_active_reaction(null);\n\tset_tracking(false);\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.assignedSlot ||\n\t\t\t\tcurrent_target.parentNode ||\n\t\t\t\t/** @type {any} */ (current_target).host ||\n\t\t\t\tnull;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, block, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data, block]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\tset_active_block(previous_block);\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-ignore remove proxy on currentTarget\n\t\tdelete event.currentTarget;\n\t\tset_active_block(previous_block);\n\t\tset_active_reaction(previous_reaction);\n\t\tset_tracking(previous_tracking);\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} [handler]\n * @param {AddEventListenerOptions} [options]\n */\nfunction create_event(event_name, dom, handler, options = {}) {\n\t/** @this {any} */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tvar previous_block = active_block;\n\t\tvar previous_reaction = active_reaction;\n\t\tvar previous_tracking = tracking;\n\n\t\ttry {\n\t\t\tset_active_block(null);\n\t\t\tset_active_reaction(null);\n\t\t\tset_tracking(false);\n\n\t\t\tif (!options.capture) {\n\t\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\t\thandle_event_propagation.call(dom, event);\n\t\t\t}\n\t\t\tif (!event.cancelBubble) {\n\t\t\t\treturn handler?.call(this, event);\n\t\t\t}\n\t\t} finally {\n\t\t\tset_active_block(previous_block);\n\t\t\tset_active_reaction(previous_reaction);\n\t\t\tset_tracking(previous_tracking);\n\t\t}\n\t}\n\n\tdom.addEventListener(event_name, target_handler, options);\n\n\treturn target_handler;\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} [handler]\n * @param {boolean} [capture]\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tcreate_event(event_name, dom, handler, options);\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/** @param {Element} target */\nexport function handle_root_events(target) {\n\tvar registered_events = new Set();\n\n\t/**\n\t * @typedef {Object} EventHandleOptions\n\t * @property {boolean} [passive]\n\t */\n\n\t/**\n\t * @typedef {(\n\t *   events: Array<string>\n\t * ) => void} EventHandle\n\t */\n\n\t/** @type {EventHandle} */\n\tvar event_handle = (/** @type {Array<string>} */ events) => {\n\t\tfor (var i = 0; i < events.length; i++) {\n\t\t\tvar event_name = events[i];\n\n\t\t\tif (registered_events.has(event_name)) continue;\n\t\t\tregistered_events.add(event_name);\n\n\t\t\t/** @type {boolean} */\n\t\t\tvar passive = is_passive_event(event_name);\n\n\t\t\t/** @type {EventHandleOptions} */\n\t\t\tvar options = { passive };\n\n\t\t\ttarget.addEventListener(event_name, handle_event_propagation, options);\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\treturn () => {\n\t\tfor (var event_name of registered_events) {\n\t\t\ttarget.removeEventListener(event_name, handle_event_propagation);\n\t\t}\n\t\troot_event_handles.delete(event_handle);\n\t};\n}\n", "/** @import { Block, Derived, CompatOptions, Component } from '#client' */\n\nimport {\n\tBLOCK_HAS_RUN,\n\tBRANCH_BLOCK,\n\tDERIVED,\n\tCONTAINS_TEARDOWN,\n\tDESTROYED,\n\tEFFECT_BLOCK,\n\tPAUSED,\n\tRENDER_BLOCK,\n\tROOT_BLOCK,\n\tTRY_BLOCK,\n\tHEAD_BLOCK,\n} from './constants.js';\nimport { next_sibling } from './operations.js';\nimport { apply_element_spread } from './render.js';\nimport {\n\tactive_block,\n\tactive_component,\n\tactive_reaction,\n\tcreate_component_ctx,\n\tis_block_dirty,\n\trun_block,\n\trun_teardown,\n\tschedule_update,\n} from './runtime.js';\nimport { suspend } from './try.js';\n\n/**\n * @param {Function} fn\n */\nexport function user_effect(fn) {\n\tif (active_block === null) {\n\t\tthrow new Error(\n\t\t\t'effect() must be called within an active context, such as a component or effect',\n\t\t);\n\t}\n\n\tvar component = active_component;\n\tif (component !== null && !component.m) {\n\t\tvar e = (component.e ??= []);\n\t\te.push({\n\t\t\tb: active_block,\n\t\t\tfn,\n\t\t\tr: active_reaction,\n\t\t});\n\n\t\treturn;\n\t}\n\n\treturn block(EFFECT_BLOCK, fn);\n}\n\n/**\n * @param {Function} fn\n */\nexport function effect(fn) {\n\treturn block(EFFECT_BLOCK, fn);\n}\n\n/**\n * @param {Function} fn\n * @param {any} [state]\n * @param {number} [flags]\n */\nexport function render(fn, state, flags = 0) {\n\treturn block(RENDER_BLOCK | flags, fn, state);\n}\n\n/**\n * @param {any} element\n * @param {any} fn\n * @param {number} [flags]\n */\nexport function render_spread(element, fn, flags = 0) {\n\treturn block(RENDER_BLOCK | flags, apply_element_spread(element, fn));\n}\n\n/**\n * @param {Function} fn\n * @param {number} [flags]\n */\nexport function branch(fn, flags = 0) {\n\treturn block(BRANCH_BLOCK | flags, fn);\n}\n\n/**\n * @param {() => any} fn\n */\nexport function async(fn) {\n\treturn block(BRANCH_BLOCK, async () => {\n\t\tconst unsuspend = suspend();\n\t\tawait fn();\n\t\tunsuspend();\n\t});\n}\n\n/**\n * @param {Element} element\n * @param {() => (element: Element) => (void | (() => void))} get_fn\n * @returns {Block}\n */\nexport function ref(element, get_fn) {\n\t/** @type {(element: Element) => (void | (() => void) | undefined)} */\n\tvar ref_fn;\n\t/** @type {Block | null} */\n\tvar e;\n\n\treturn block(RENDER_BLOCK, () => {\n\t\tif (ref_fn !== (ref_fn = get_fn())) {\n\t\t\tif (e) {\n\t\t\t\tdestroy_block(e);\n\t\t\t\te = null;\n\t\t\t}\n\n\t\t\tif (ref_fn) {\n\t\t\t\te = branch(() => {\n\t\t\t\t\teffect(() => {\n\t\t\t\t\t\treturn ref_fn(element);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t});\n}\n\n/**\n * @param {() => (void | (() => void))} fn\n * @param {CompatOptions} [compat]\n * @returns {Block}\n */\nexport function root(fn, compat) {\n\tvar target_fn = fn;\n\n\tif (compat != null) {\n\t\t/** @type {Array<void | (() => void)>} */\n\t\tvar unmounts = [];\n\t\tfor (var key in compat) {\n\t\t\tvar api = compat[key];\n\t\t\tunmounts.push(api.createRoot());\n\t\t}\n\t\ttarget_fn = () => {\n\t\t\tvar component_unmount = fn();\n\n\t\t\treturn () => {\n\t\t\t\tcomponent_unmount?.();\n\t\t\t\tfor (var unmount of unmounts) {\n\t\t\t\t\tunmount?.();\n\t\t\t\t}\n\t\t\t};\n\t\t};\n\t}\n\n\treturn block(ROOT_BLOCK, target_fn, { compat }, create_component_ctx());\n}\n\n/**\n * @param {() => void} fn\n * @param {any} state\n * @returns {Block}\n */\nexport function create_try_block(fn, state) {\n\treturn block(TRY_BLOCK, fn, state);\n}\n\n/**\n * @param {Block} block\n * @param {Block} parent_block\n */\nfunction push_block(block, parent_block) {\n\tvar parent_last = parent_block.last;\n\tif (parent_last === null) {\n\t\tparent_block.last = parent_block.first = block;\n\t} else {\n\t\tparent_last.next = block;\n\t\tblock.prev = parent_last;\n\t\tparent_block.last = block;\n\t}\n}\n\n/**\n * @param {number} flags\n * @param {Function} fn\n * @param {any} [state]\n * @param {Component} [co]\n * @returns {Block}\n */\nexport function block(flags, fn, state = null, co) {\n\t/** @type {Block} */\n\tvar block = {\n\t\tco: co || active_component,\n\t\td: null,\n\t\tfirst: null,\n\t\tf: flags,\n\t\tfn,\n\t\tlast: null,\n\t\tnext: null,\n\t\tp: active_block,\n\t\tprev: null,\n\t\ts: state,\n\t\tt: null,\n\t};\n\n\tif (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {\n\t\t/* prettier-ignore */\n\t\t(/** @type {Derived} */ (active_reaction).blocks ??= []).push(block);\n\t}\n\n\tif (active_block !== null) {\n\t\tpush_block(block, active_block);\n\t}\n\n\tif ((flags & EFFECT_BLOCK) !== 0) {\n\t\tschedule_update(block);\n\t} else {\n\t\trun_block(block);\n\t\tblock.f ^= BLOCK_HAS_RUN;\n\t}\n\n\treturn block;\n}\n\n/**\n * @param {Block} parent\n * @param {boolean} [remove_dom]\n */\nexport function destroy_block_children(parent, remove_dom = false) {\n\tvar block = parent.first;\n\tparent.first = parent.last = null;\n\n\tif ((parent.f & CONTAINS_TEARDOWN) !== 0) {\n\t\twhile (block !== null) {\n\t\t\tvar next = block.next;\n\t\t\tdestroy_block(block, remove_dom);\n\t\t\tblock = next;\n\t\t}\n\t}\n}\n\n/**\n * @param {Block} parent\n * @param {boolean} [remove_dom]\n */\nexport function destroy_non_branch_children(parent, remove_dom = false) {\n\tvar block = parent.first;\n\n\tif (\n\t\t(parent.f & CONTAINS_TEARDOWN) === 0 &&\n\t\tparent.first !== null &&\n\t\t(parent.first.f & BRANCH_BLOCK) === 0\n\t) {\n\t\tparent.first = parent.last = null;\n\t} else {\n\t\twhile (block !== null) {\n\t\t\tvar next = block.next;\n\t\t\tif ((block.f & BRANCH_BLOCK) === 0) {\n\t\t\t\tdestroy_block(block, remove_dom);\n\t\t\t}\n\t\t\tblock = next;\n\t\t}\n\t}\n}\n\n/**\n * @param {Block} block\n */\nexport function unlink_block(block) {\n\tvar parent = block.p;\n\tvar prev = block.prev;\n\tvar next = block.next;\n\n\tif (prev !== null) prev.next = next;\n\tif (next !== null) next.prev = prev;\n\n\tif (parent !== null) {\n\t\tif (parent.first === block) parent.first = next;\n\t\tif (parent.last === block) parent.last = prev;\n\t}\n}\n\n/**\n * @param {Block} block\n */\nexport function pause_block(block) {\n\tif ((block.f & PAUSED) !== 0) {\n\t\treturn;\n\t}\n\tblock.f ^= PAUSED;\n\n\tvar child = block.first;\n\n\twhile (child !== null) {\n\t\tvar next = child.next;\n\t\tpause_block(child);\n\t\tchild = next;\n\t}\n\n\trun_teardown(block);\n}\n\n/**\n * @param {Block} block\n */\nexport function resume_block(block) {\n\tif ((block.f & PAUSED) === 0) {\n\t\treturn;\n\t}\n\tblock.f ^= PAUSED;\n\n\tif (is_block_dirty(block)) {\n\t\tschedule_update(block);\n\t}\n\n\tvar child = block.first;\n\n\twhile (child !== null) {\n\t\tvar next = child.next;\n\t\tresume_block(child);\n\t\tchild = next;\n\t}\n}\n\n/**\n * @param {Block} target_block\n * @returns {boolean}\n */\nexport function is_destroyed(target_block) {\n\t/** @type {Block | null} */\n\tvar block = target_block;\n\n\twhile (block !== null) {\n\t\tvar flags = block.f;\n\n\t\tif ((flags & DESTROYED) !== 0) {\n\t\t\treturn true;\n\t\t}\n\t\tif ((flags & ROOT_BLOCK) !== 0) {\n\t\t\treturn false;\n\t\t}\n\t\tblock = block.p;\n\t}\n\treturn true;\n}\n\n/**\n * @param {Node | null} node\n * @param {Node} end\n */\nexport function remove_block_dom(node, end) {\n\twhile (node !== null) {\n\t\t/** @type {Node | null} */\n\t\tvar next = node === end ? null : next_sibling(node);\n\n\t\t/** @type {Element | Text | Comment} */ (node).remove();\n\t\tnode = next;\n\t}\n}\n\n/**\n * @param {Block} block\n * @param {boolean} [remove_dom]\n */\nexport function destroy_block(block, remove_dom = true) {\n\tblock.f ^= DESTROYED;\n\n\tvar removed = false;\n\tvar f = block.f;\n\n\tif ((remove_dom && (f & (BRANCH_BLOCK | ROOT_BLOCK)) !== 0) || (f & HEAD_BLOCK) !== 0) {\n\t\tvar s = block.s;\n\t\tremove_block_dom(s.start, s.end);\n\t\tremoved = true;\n\t}\n\n\tdestroy_block_children(block, remove_dom && !removed);\n\n\trun_teardown(block);\n\n\tvar parent = block.p;\n\n\t// If the parent doesn't have any children, then skip this work altogether\n\tif (parent !== null && parent.first !== null) {\n\t\tunlink_block(block);\n\t}\n\n\tblock.fn = block.s = block.d = block.p = block.d = block.co = block.t = null;\n}\n", "import { DEV } from 'esm-env';\n\nexport function remove_ssr_css() {\n\tif (!document || typeof requestAnimationFrame !== 'function') {\n\t\treturn;\n\t}\n\n\tremove_styles();\n}\n\nfunction remove_styles() {\n\tif (DEV) {\n\t\tconst styles = document.querySelector('style[data-vite-dev-id]');\n\t\tif (styles) {\n\t\t\tremove();\n\t\t} else {\n\t\t\trequestAnimationFrame(remove_styles);\n\t\t}\n\t} else {\n\t\tremove_when_css_loaded(() => requestAnimationFrame(remove));\n\t}\n}\n\nfunction remove() {\n\tdocument.querySelectorAll('style[data-ripple-ssr]').forEach((el) => el.remove());\n}\n\n/**\n * @param {function} callback\n * @returns {void}\n */\nfunction remove_when_css_loaded(callback) {\n\t/** @type {HTMLLinkElement[]} */\n\tconst links = Array.from(document.querySelectorAll('link[rel=\"stylesheet\"]'));\n\tlet remaining = links.length;\n\n\tif (remaining === 0) {\n\t\tcallback();\n\t\treturn;\n\t}\n\n\tconst done = () => {\n\t\tremaining--;\n\t\tif (remaining === 0) {\n\t\t\t// clean up all listeners\n\t\t\tlinks.forEach((link) => {\n\t\t\t\tlink.removeEventListener('load', onLoad);\n\t\t\t\tlink.removeEventListener('error', onError);\n\t\t\t});\n\t\t\tcallback();\n\t\t}\n\t};\n\n\tfunction onLoad() {\n\t\tdone();\n\t}\n\tfunction onError() {\n\t\tdone();\n\t}\n\n\tlinks.forEach((link) => {\n\t\tif (link.sheet) {\n\t\t\t// already loaded (possibly cached)\n\t\t\tdone();\n\t\t} else {\n\t\t\tlink.addEventListener('load', onLoad);\n\t\t\tlink.addEventListener('error', onError);\n\t\t}\n\t});\n}\n", "/**\n * Ripple JSX Runtime\n * This module provides the JSX runtime functions that TypeScript will automatically import\n * when using jsxImportSource: \"ripple/jsx-runtime\"\n */\n\n/**\n * Create a JSX element (for elements with children)\n * In Ripple, components don't return values - they imperatively render to the DOM\n * @param {string | Function} type - Element type (tag name or component function)\n * @param {object} props - Element properties\n * @param {string} key - Element key (optional)\n * @returns {void} Ripple components don't return anything\n */\nexport function jsx(type, props, key) {\n  // Ripple components are imperative - they don't return JSX elements\n  // This is a placeholder for the actual Ripple rendering logic\n  if (typeof type === 'function') {\n    // Call the Ripple component function\n    type(props);\n  } else {\n    // Handle DOM elements\n    console.warn('DOM element rendering not implemented in jsx runtime:', type, props);\n  }\n}\n\n/**\n * Create a JSX element with static children (optimization for multiple children)\n * @param {string | Function} type - Element type (tag name or component function)\n * @param {object} props - Element properties\n * @param {string} key - Element key (optional)\n * @returns {void} Ripple components don't return anything\n */\nexport function jsxs(type, props, key) {\n  return jsx(type, props, key);\n}\n\n/**\n * JSX Fragment component\n * @param {object} props - Fragment props (should contain children)\n * @returns {void} Ripple fragments don't return anything\n */\nexport function Fragment(props) {\n  // Ripple fragments are imperative\n  console.warn('Fragment rendering not implemented in jsx runtime:', props);\n}\n", "/** @import { Component } from '#client' */\n\nimport { active_component } from './runtime.js';\n\n/**\n * @template T\n */\nexport class Context {\n\t/**\n\t * @param {T} initial_value\n\t */\n\tconstructor(initial_value) {\n\t\t/** @type {T} */\n\t\tthis._v = initial_value;\n\t}\n\n\tget() {\n\t\tconst component = active_component;\n\t\tconst context = this;\n\n\t\tif (component === null) {\n\t\t\tthrow new Error('No active component found, cannot get context');\n\t\t}\n\t\t/** @type {Component | null} */\n\t\tlet current_component = component;\n\n\t\twhile (current_component !== null) {\n\t\t\tconst context_map = current_component.c;\n\n\t\t\tif (context_map?.has(context)) {\n\t\t\t\treturn context_map.get(context);\n\t\t\t}\n\n\t\t\tcurrent_component = current_component.p;\n\t\t}\n\n\t\treturn context._v;\n\t}\n\n\t/**\n\t * @template T\n\t * @param {T} value\n\t */\n\tset(value) {\n\t\tconst component = active_component;\n\t\tconst context = this;\n\n\t\tif (component === null) {\n\t\t\tthrow new Error('No active component found, cannot set context');\n\t\t}\n\n\t\tlet current_context = component.c;\n\n\t\tif (current_context === null) {\n\t\t\tcurrent_context = component.c = new Map();\n\t\t}\n\n\t\tcurrent_context.set(context, value);\n\t}\n}\n", "/** @import { Block, Tracked } from '#client' */\n/** @import { TrackedArray } from './array.js' */\n/** @import { TrackedObject } from './object.js' */\n\nimport { get, set, tracked } from './internal/client/runtime.js';\nimport {\n\tarray_prototype,\n\tget_descriptor,\n\tget_prototype_of,\n\tis_array,\n\tobject_prototype,\n} from './internal/client/utils.js';\nimport {\n\tMAX_ARRAY_LENGTH,\n\tTRACKED_ARRAY,\n\tTRACKED_OBJECT,\n\tUNINITIALIZED,\n} from './internal/client/constants.js';\n\n/**\n * @template T\n * @param {T[] | Record<PropertyKey, any>} value\n * @param {Block} block\n * @returns {TrackedArray<T> | TrackedObject<T>}\n */\nexport function proxy(value, block) {\n\t// if non-proxyable, or is already a proxy, return `value`\n\tif (\n\t\ttypeof value !== 'object'\n\t\t|| value === null\n\t\t|| TRACKED_ARRAY in value\n\t\t|| TRACKED_OBJECT in value\n\t) {\n\t\treturn value;\n\t}\n\n\tconst prototype = get_prototype_of(value);\n\n\tif (prototype !== object_prototype && prototype !== array_prototype) {\n\t\treturn value;\n\t}\n\n\t/** @type {Map<any,Tracked>} */\n\tvar tracked_elements = new Map();\n\tvar is_proxied_array = is_array(value);\n\t/** @type {Tracked} */\n\tvar tracked_len;\n\n\tif (is_proxied_array) {\n\t\ttracked_len = tracked(value.length, block);\n\t\ttracked_elements.set('length', tracked_len);\n\t}\n\n\treturn new Proxy(value, {\n\t\t/**\n\t\t * @param {PropertyKey} prop\n\t\t */\n\t\tget(target, prop, receiver) {\n\t\t\tvar t = tracked_elements.get(prop);\n\t\t\tvar exists = prop in target;\n\n\t\t\tif (t === undefined && (!exists || get_descriptor(target, prop)?.writable)) {\n\t\t\t\tt = tracked(exists ? /** @type {any} */ (target)[prop] : UNINITIALIZED, block);\n\t\t\t\ttracked_elements.set(prop, t);\n\t\t\t}\n\n\t\t\tif (t !== undefined) {\n\t\t\t\tvar v = get(t);\n\t\t\t\treturn v === UNINITIALIZED ? undefined : v;\n\t\t\t}\n\n\t\t\tvar result = Reflect.get(target, prop, receiver);\n\n\t\t\tif (typeof result === 'function') {\n\t\t\t\tif (methods_returning_arrays.has(prop)) {\n\t\t\t\t\t/** @type {(this: any, ...args: any[]) => any} */\n\t\t\t\t\treturn function (...args) {\n\t\t\t\t\t\tvar output = Reflect.apply(result, receiver, args);\n\n\t\t\t\t\t\tif (Array.isArray(output) && output !== target) {\n\t\t\t\t\t\t\treturn array_proxy({ elements: output, block, use_array: true });\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn output;\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\t// When generating an iterator, we need to ensure that length is tracked\n\t\t\t\tif (is_proxied_array && (prop === 'entries' || prop === 'values' || prop === 'keys')) {\n\t\t\t\t\treceiver.length;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn result;\n\t\t},\n\n\t\tset(target, prop, value, receiver) {\n\t\t\tvar t = tracked_elements.get(prop);\n\t\t\tvar exists = prop in target;\n\n\t\t\tif (is_proxied_array && prop === 'length' && t !== undefined) {\n\t\t\t\tfor (var i = value; i < t.__v; i += 1) {\n\t\t\t\t\tvar other_t = tracked_elements.get(i + '');\n\t\t\t\t\tif (other_t !== undefined) {\n\t\t\t\t\t\tset(other_t, UNINITIALIZED);\n\t\t\t\t\t} else if (i in target) {\n\t\t\t\t\t\t// If the item exists in the original, we need to create a uninitialized tracked,\n\t\t\t\t\t\t// else a later read of the property would result in a tracked being created with\n\t\t\t\t\t\t// the value of the original item at that index.\n\t\t\t\t\t\tother_t = tracked(UNINITIALIZED, block);\n\t\t\t\t\t\ttracked_elements.set(i + '', other_t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If we haven't yet created a tracked for this property, we need to ensure\n\t\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t\t// object property before writing to that property.\n\t\t\tif (t === undefined) {\n\t\t\t\tif (!exists || get_descriptor(target, prop)?.writable) {\n\t\t\t\t\tt = tracked(undefined, block);\n\t\t\t\t\tset(t, value);\n\n\t\t\t\t\ttracked_elements.set(prop, t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\texists = t.__v !== UNINITIALIZED;\n\n\t\t\t\tset(t, value);\n\t\t\t}\n\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\t// Set the new value before updating any tracked's so that any listeners get the new value\n\t\t\tif (descriptor?.set) {\n\t\t\t\tdescriptor.set.call(receiver, value);\n\t\t\t}\n\n\t\t\tif (!exists && is_proxied_array && typeof prop === 'string') {\n\t\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t\t// will not cause the length to be out of sync.\n\t\t\t\tvar n = Number(prop);\n\n\t\t\t\tif (Number.isInteger(n) && n >= tracked_len.__v) {\n\t\t\t\t\tset(tracked_len, n + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\tsetPrototypeOf() {\n\t\t\tthrow new Error(`Cannot set prototype of ${is_proxied_array ? '\\`TrackedArray\\`' : '\\`TrackedObject\\`'}`);\n\t\t},\n\n\t\tdeleteProperty(target, prop) {\n\t\t\tvar t = tracked_elements.get(prop);\n\n\t\t\tif (t === undefined) {\n\t\t\t\tif (prop in target) {\n\t\t\t\t\tconst t = tracked(UNINITIALIZED, block);\n\t\t\t\t\ttracked_elements.set(prop, t);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tset(t, UNINITIALIZED);\n\t\t\t}\n\n\t\t\treturn Reflect.deleteProperty(target, prop);\n\t\t},\n\n\t\thas(target, prop) {\n\t\t\tif (is_proxied_array && prop === TRACKED_ARRAY) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (prop === TRACKED_OBJECT) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tvar t = tracked_elements.get(prop);\n\t\t\tvar exists = (t !== undefined && t.__v !== UNINITIALIZED) || Reflect.has(target, prop);\n\n\t\t\tif (t !== undefined || !exists || get_descriptor(target, prop)?.writable) {\n\t\t\t\tif (t === undefined) {\n\t\t\t\t\tt = tracked(exists ?  /** @type {any} */ (target)[prop] : UNINITIALIZED, block);\n\n\t\t\t\t\ttracked_elements.set(prop, t);\n\t\t\t\t}\n\n\t\t\t\tvar value = get(t);\n\t\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn exists;\n\t\t},\n\n\t\tdefineProperty(_, prop, descriptor) {\n\t\t\tif (\n\t\t\t\t!('value' in descriptor) ||\n\t\t\t\tdescriptor.configurable === false ||\n\t\t\t\tdescriptor.enumerable === false ||\n\t\t\t\tdescriptor.writable === false\n\t\t\t) {\n\t\t\t\t// we disallow non-basic descriptors, because unless they are applied to the\n\t\t\t\t// target object  which we avoid, so that state can be forked  we will run\n\t\t\t\t// afoul of the various invariants\n\t\t\t\t// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/getOwnPropertyDescriptor#invariants\n\t\t\t\tthrow new Error(\n\t\t\t\t\t'Only basic property descriptors are supported with value and configurable, enumerable, and writable set to true',\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tvar t = tracked_elements.get(prop);\n\n\t\t\tif (t === undefined) {\n\t\t\t\tt = tracked(descriptor.value, block);\n\t\t\t\ttracked_elements.set(prop, t);\n\t\t\t} else {\n\t\t\t\tset(t, descriptor.value);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t},\n\n\t\townKeys(target) {\n\t\t\tvar own_keys = Reflect.ownKeys(target).filter((key) => {\n\t\t\t\tvar t = tracked_elements.get(key);\n\t\t\t\treturn t === undefined || t.__v !== UNINITIALIZED;\n\t\t\t});\n\n\t\t\tfor (var [key, t] of tracked_elements) {\n\t\t\t\tif (t.__v !== UNINITIALIZED && !(key in target)) {\n\t\t\t\t\town_keys.push(key);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn own_keys;\n\t\t},\n\n\t\tgetOwnPropertyDescriptor(target, prop) {\n\t\t\tvar descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\n\t\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t\tvar t = tracked_elements.get(prop);\n\t\t\t\tif (t) descriptor.value = get(t);\n\t\t\t} else if (descriptor === undefined) {\n\t\t\t\tvar t = tracked_elements.get(prop);\n\t\t\t\tvar value = t?.__v;\n\n\t\t\t\tif (t !== undefined && value !== UNINITIALIZED) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tenumerable: true,\n\t\t\t\t\t\tconfigurable: true,\n\t\t\t\t\t\tvalue,\n\t\t\t\t\t\twritable: true\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn descriptor;\n\t\t},\n\n\t});\n}\n\n/**\n * @template T\n * @param {{\n *  elements: Iterable<T>,\n *  block: Block,\n *  from_static?: boolean,\n *  use_array?: boolean\n * }} params\n * @returns {TrackedArray<T>}\n */\nexport function array_proxy({ elements, block, from_static = false, use_array = false }) {\n\tvar arr;\n\tvar first;\n\n\tif (\n\t\tfrom_static &&\n\t\t(first = get_first_if_length(/** @type {Array<T>} */(elements))) !== undefined\n\t) {\n\t\tarr = new Array();\n\t\tarr[0] = first;\n\t} else if (use_array) {\n\t\tarr = elements;\n\t} else {\n\t\tarr = new Array(...elements);\n\t}\n\n\treturn proxy(arr, block);\n}\n\n/**\n * @template {object} T\n * @param {T} obj\n * @param {Block} block\n * @returns {TrackedObject<T>}\n */\nexport function object_proxy(obj, block) {\n\treturn proxy(obj, block);\n}\n\n/** @type {Set<PropertyKey>} */\nconst methods_returning_arrays = new Set([\n\t'concat',\n\t'filter',\n\t'flat',\n\t'flatMap',\n\t'map',\n\t'slice',\n\t'splice',\n\t'toReversed',\n\t'toSorted',\n\t'toSpliced',\n\t'with',\n]);\n\n/**\n * @template T\n * @param {Array<T>} array\n * @returns {number | void}\n */\nfunction get_first_if_length(array) {\n\tvar first = array[0];\n\n\tif (\n\t\tarray.length === 1 &&\n\t\t0 in array &&\n\t\tNumber.isInteger(first) &&\n    /** @type {number} */ (first) >= 0 &&\n    /** @type {number} */ (first) <= MAX_ARRAY_LENGTH\n\t) {\n\t\treturn /** @type {number} */ (first);\n\t}\n}\n", "/** @import { Block } from '#client' */\nimport { safe_scope } from './internal/client/runtime.js';\nimport { array_proxy } from './proxy.js';\n\n/**\n * @template T\n * @constructor\n * @param {...T} elements\n * @returns {TrackedArray<T>}\n */\nexport function TrackedArray(...elements) {\n  if (!new.target) {\n    throw new Error(\"TrackedArray must be called with 'new'\");\n  }\n\n  var block = safe_scope();\n  return array_proxy({ elements, block });\n}\n\n/**\n * @template T\n * @param {ArrayLike<T> | Iterable<T>} arrayLike\n * @param {(v: T, k: number) => any | undefined} [mapFn]\n * @param {*} [thisArg]\n * @returns {TrackedArray<T>}\n */\nTrackedArray.from = function (arrayLike, mapFn, thisArg) {\n  var block = safe_scope();\n  var elements = mapFn ? Array.from(arrayLike, mapFn, thisArg) : Array.from(arrayLike);\n  return array_proxy({ elements, block, from_static: true });\n};\n\n/**\n * @template T\n * @param {...T} items\n * @returns {TrackedArray<T>}\n */\nTrackedArray.of = function (...items) {\n  var block = safe_scope();\n  var elements = Array.of(...items);\n  return array_proxy({ elements, block, from_static: true });\n};\n\n/**\n * @template T\n * @param {ArrayLike<T> | Iterable<T>} arrayLike\n * @param {(v: T, k: number) => any | undefined} [mapFn]\n * @param {any} [thisArg]\n * @returns {Promise<TrackedArray<T>>}\n */\nTrackedArray.fromAsync = async function (arrayLike, mapFn, thisArg) {\n  var block = safe_scope();\n  var elements = mapFn\n    ? await Array.fromAsync(arrayLike, mapFn, thisArg)\n    : await Array.fromAsync(arrayLike);\n  return array_proxy({ elements, block, from_static: true });\n};\n\n/**\n * @template T\n * @param {Array<T>} elements\n * @param {Block} block\n * @returns {TrackedArray<T>}\n */\nexport function tracked_array(elements, block) {\n  return array_proxy({ elements, block, from_static: true });\n}\n", "/** @import { Block } from '#client' */\nimport { safe_scope } from './internal/client/runtime.js';\nimport { object_proxy } from './proxy.js';\n\n/**\n * @template {object} T\n * @constructor\n * @param {T} obj\n * @returns {TrackedObject<T>}\n */\nexport function TrackedObject(obj) {\n  if (!new.target) {\n    throw new Error(\"TrackedObject must be called with 'new'\");\n  }\n\n  var block = safe_scope();\n\n  return object_proxy(obj, block);\n}\n\n/**\n * @template {object} T\n * @param {T} obj\n * @param {Block} block\n * @returns {TrackedObject<T>}\n */\nexport function tracked_object(obj, block) {\n  return object_proxy(obj, block);\n}\n", "/** @import { Block, Tracked } from '#client' */\nimport { get, increment, safe_scope, set, tracked, with_scope } from './internal/client/runtime.js';\n\nconst introspect_methods = ['entries', 'forEach', 'keys', 'values', Symbol.iterator];\n\nconst compare_other_methods = ['isDisjointFrom', 'isSubsetOf', 'isSupersetOf'];\n\nconst new_other_methods = ['difference', 'intersection', 'symmetricDifference', 'union'];\n\nlet init = false;\n\n/**\n * @template T\n * @extends {Set<T>}\n * @returns {TrackedSet<T>}\n */\nexport class TrackedSet extends Set {\n\t/** @type {Tracked} */\n\t#tracked_size;\n\t/** @type {Map<T, Tracked>} */\n\t#tracked_items = new Map();\n\t/** @type {Block} */\n\t#block;\n\n\t/**\n\t * @param {Iterable<T>} [iterable]\n\t */\n\tconstructor(iterable) {\n\t\tsuper();\n\n\t\tvar block = this.#block = safe_scope();\n\n\t\tif (iterable) {\n\t\t\tfor (var item of iterable) {\n\t\t\t\tsuper.add(item);\n\t\t\t\tthis.#tracked_items.set(item, tracked(0, block));\n\t\t\t}\n\t\t}\n\n\t\tthis.#tracked_size = tracked(super.size, block);\n\n\t\tif (!init) {\n\t\t\tinit = true;\n\t\t\tthis.#init();\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t#init() {\n\t\tvar proto = TrackedSet.prototype;\n\t\tvar set_proto = Set.prototype;\n\n\t\tfor (const method of introspect_methods) {\n\t\t\tif (!(method in set_proto)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n      /** @type {any} */ (proto)[method] = function (/** @type {...any} */ ...v) {\n\t\t\t\tthis.size;\n\n\t\t\t\treturn /** @type {any} */ (set_proto)[method].apply(this, v);\n\t\t\t};\n\t\t}\n\n\t\tfor (const method of compare_other_methods) {\n\t\t\tif (!(method in set_proto)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n      /** @type {any} */ (proto)[method] = function (/** @type {any} */ other, /** @type {...any} */ ...v) {\n\t\t\t\tthis.size;\n\n\t\t\t\tif (other instanceof TrackedSet) {\n\t\t\t\t\tother.size;\n\t\t\t\t}\n\n\t\t\t\treturn /** @type {any} */ (set_proto)[method].apply(this, [other, ...v]);\n\t\t\t};\n\t\t}\n\n\t\tfor (const method of new_other_methods) {\n\t\t\tif (!(method in set_proto)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n      /** @type {any} */ (proto)[method] = function (/** @type {any} */ other, /** @type {...any} */ ...v) {\n\t\t\t\tthis.size;\n\n\t\t\t\tif (other instanceof TrackedSet) {\n\t\t\t\t\tother.size;\n\t\t\t\t}\n\n\t\t\t\treturn new TrackedSet(/** @type {any} */(set_proto)[method].apply(this, [other, ...v]));\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {T} value\n\t * @returns {this}\n\t */\n\tadd(value) {\n\t\tvar block = this.#block;\n\n\t\tif (!super.has(value)) {\n\t\t\tsuper.add(value);\n\t\t\tthis.#tracked_items.set(value, tracked(0, block));\n\t\t\tset(this.#tracked_size, super.size);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {T} value\n\t * @returns {boolean}\n\t */\n\tdelete(value) {\n\t\tvar block = this.#block;\n\n\t\tif (!super.delete(value)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tvar t = this.#tracked_items.get(value);\n\n\t\tif (t) {\n\t\t\tincrement(t);\n\t\t}\n\t\tthis.#tracked_items.delete(value);\n\t\tset(this.#tracked_size, super.size);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * @param {T} value\n\t * @return {boolean}\n\t*/\n\thas(value) {\n\n\t\tvar has = super.has(value);\n\t\tvar tracked_items = this.#tracked_items;\n\t\tvar t = tracked_items.get(value);\n\n\t\tif (t === undefined) {\n\t\t\t// if no tracked it also means super didn't have it\n\t\t\t// It's not possible to have a disconnect, we track each value\n\t\t\t// If the value doesn't exist, track the size in case it's added later\n\t\t\t// but don't create tracked entries willy-nilly to track all possible values\n\t\t\tthis.size;\n\t\t} else {\n\t\t\tget(t);\n\t\t}\n\n\t\treturn has;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tclear() {\n\t\tvar block = this.#block;\n\n\t\tif (super.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var [_, t] of this.#tracked_items) {\n\t\t\tincrement(t);\n\t\t}\n\n\t\tsuper.clear();\n\t\tthis.#tracked_items.clear();\n\t\tset(this.#tracked_size, 0);\n\t}\n\n\t/**\n\t * @returns {number}\n\t */\n\tget size() {\n\t\treturn get(this.#tracked_size);\n\t}\n\n\t/**\n\t * @returns {T[]}\n\t */\n\ttoJSON() {\n\t\tthis.size;\n\n\t\treturn [...this];\n\t}\n}\n\n/**\n * @template V\n * @param {Block} block\n * @param {...any} args\n * @returns {TrackedSet<V>}\n */\nexport function tracked_set(block, ...args) {\n\treturn with_scope(block, () => new TrackedSet(...args));\n}\n", "/** @import { Block, Tracked } from '#client' */\nimport { get, increment, safe_scope, set, tracked, with_scope } from './internal/client/runtime.js';\n\nconst introspect_methods = ['entries', 'forEach', 'values', Symbol.iterator];\n\nlet init = false;\n\n/**\n * @template K, V\n * @extends {Map<K, V>}\n * @returns {TrackedMap<K, V>}\n */\nexport class TrackedMap extends Map {\n\t/** @type {Tracked} */\n\t#tracked_size;\n\t/** @type {Map<K, Tracked>} */\n\t#tracked_items = new Map();\n\t/** @type {Block} */\n\t#block;\n\n\t/**\n\t * @param {Iterable<readonly [K, V]>} [iterable]\n\t */\n\tconstructor(iterable) {\n\t\tsuper();\n\n\t\tvar block = this.#block = safe_scope();\n\n\t\tif (iterable) {\n\t\t\tfor (var [key, value] of iterable) {\n\t\t\t\tsuper.set(key, value);\n\t\t\t\tthis.#tracked_items.set(key, tracked(0, block));\n\t\t\t}\n\t\t}\n\n\t\tthis.#tracked_size = tracked(super.size, block);\n\n\t\tif (!init) {\n\t\t\tinit = true;\n\t\t\tthis.#init();\n\t\t}\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t#init() {\n\t\tvar proto = TrackedMap.prototype;\n\t\tvar map_proto = Map.prototype;\n\n\t\tfor (const method of introspect_methods) {\n      /** @type {any} */ (proto)[method] = function (/** @type {...any} */ ...v) {\n\t\t\t\tthis.size;\n\t\t\t\tthis.#read_all();\n\n\t\t\t\treturn /** @type {any} */ (map_proto)[method].apply(this, v);\n\t\t\t};\n\t\t}\n\t}\n\n\t/**\n\t * @param {K} key\n\t * @returns {V | undefined}\n\t */\n\tget(key) {\n\t\tvar tracked_items = this.#tracked_items;\n\t\tvar t = tracked_items.get(key);\n\n\t\tif (t === undefined) {\n\t\t\t// same logic as has\n\t\t\tthis.size;\n\t\t} else {\n\t\t\tget(t);\n\t\t}\n\n\t\treturn super.get(key);\n\t}\n\n\t/**\n\t * @param {K} key\n\t * @returns {boolean}\n\t */\n\thas(key) {\n\t\tvar has = super.has(key);\n\t\tvar tracked_items = this.#tracked_items;\n\t\tvar t = tracked_items.get(key);\n\n\t\tif (t === undefined) {\n\t\t\t// if no tracked it also means super didn't have it\n\t\t\t// It's not possible to have a disconnect, we tract each key\n\t\t\t// If the key doesn't exist, track the size in case it's added later\n\t\t\t// but don't create tracked entries willy-nilly to track all possible keys\n\t\t\tthis.size;\n\t\t} else {\n\t\t\tget(t);\n\t\t}\n\n\t\treturn has;\n\t}\n\n\t/**\n\t * @param {K} key\n\t * @param {V} value\n\t * @returns {this}\n\t */\n\tset(key, value) {\n\t\tvar block = this.#block;\n\t\tvar tracked_items = this.#tracked_items;\n\t\tvar t = tracked_items.get(key);\n\t\tvar prev_res = super.get(key);\n\n\t\tsuper.set(key, value);\n\n\t\tif (!t) {\n\t\t\ttracked_items.set(key, tracked(0, block));\n\t\t\tset(this.#tracked_size, super.size);\n\t\t} else if (prev_res !== value) {\n\t\t\tincrement(t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param {K} key\n\t * @returns {boolean}\n\t */\n\tdelete(key) {\n\t\tvar block = this.#block;\n\t\tvar tracked_items = this.#tracked_items;\n\t\tvar t = tracked_items.get(key);\n\t\tvar result = super.delete(key);\n\n\t\tif (t) {\n\t\t\tincrement(t);\n\t\t\ttracked_items.delete(key);\n\t\t\tset(this.#tracked_size, super.size);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\tclear() {\n\t\tvar block = this.#block;\n\n\t\tif (super.size === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (var [_, t] of this.#tracked_items) {\n\t\t\tincrement(t);\n\t\t}\n\n\t\tsuper.clear();\n\t\tthis.#tracked_items.clear();\n\t\tset(this.#tracked_size, 0);\n\t}\n\n\t/**\n\t * @returns {MapIterator<K>}\n\t */\n\tkeys() {\n\t\tthis.size;\n\t\treturn super.keys();\n\t}\n\n\t/**\n\t * @returns {void}\n\t */\n\t#read_all() {\n\t\tfor (const [, t] of this.#tracked_items) {\n\t\t\tget(t);\n\t\t}\n\t}\n\n\t/**\n\t * @returns {number}\n\t */\n\tget size() {\n\t\treturn get(this.#tracked_size);\n\t}\n\n\t/**\n\t * @returns {Array<[K, V]>}\n\t */\n\ttoJSON() {\n\t\tthis.size;\n\t\tthis.#read_all();\n\n\t\treturn [...this];\n\t}\n}\n\n/**\n * @template K, V\n * @param {Block} block\n * @param {...any} args\n * @returns {TrackedMap<K, V>}\n */\nexport function tracked_map(block, ...args) {\n\treturn with_scope(block, () => new TrackedMap(...args));\n}\n", "/** @import { Block, Derived } from '#client' */\nimport { safe_scope, tracked, get, derived, set } from './internal/client/runtime.js';\n\nvar init = false;\n\nexport class TrackedDate extends Date {\n\t#time;\n\t/** @type {Map<keyof Date, Derived>} */\n\t#deriveds = new Map();\n\t/** @type {Block} */\n\t#block;\n\n\t/** @param {any[]} params */\n\tconstructor(...params) {\n\t\t// @ts-ignore\n\t\tsuper(...params);\n\n\t\tvar block = this.#block = safe_scope();\n\t\tthis.#time = tracked(super.getTime(), block);\n\n\t\tif (!init) this.#init();\n\t}\n\n\t#init() {\n\t\tinit = true;\n\n\t\tvar proto = TrackedDate.prototype;\n\t\tvar date_proto = Date.prototype;\n\n\t\tvar methods = /** @type {Array<keyof Date & string>} */ (\n\t\t\tObject.getOwnPropertyNames(date_proto)\n\t\t);\n\n\t\tfor (const method of methods) {\n\t\t\tif (method.startsWith('get') || method.startsWith('to') || method === 'valueOf') {\n\t\t\t\t// @ts-ignore\n\t\t\t\tproto[method] = function (...args) {\n\t\t\t\t\t// don't memoize if there are arguments\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tif (args.length > 0) {\n\t\t\t\t\t\tget(this.#time);\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\treturn date_proto[method].apply(this, args);\n\t\t\t\t\t}\n\n\t\t\t\t\tvar d = this.#deriveds.get(method);\n\n\t\t\t\t\tif (d === undefined) {\n\t\t\t\t\t\td = derived(() => {\n\t\t\t\t\t\t\tget(this.#time);\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn date_proto[method].apply(this, args);\n\t\t\t\t\t\t}, this.#block);\n\n\t\t\t\t\t\tthis.#deriveds.set(method, d);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn get(d);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (method.startsWith('set')) {\n\t\t\t\t// @ts-ignore\n\t\t\t\tproto[method] = function (...args) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tvar result = date_proto[method].apply(this, args);\n\t\t\t\t\tset(this.#time, date_proto.getTime.call(this));\n\t\t\t\t\treturn result;\n\t\t\t\t};\n\t\t\t}\n\t\t}\n\t}\n}\n", "import { get, increment, safe_scope, tracked } from './internal/client/runtime.js';\nimport { get_current_url } from './url.js';\n\nexport const REPLACE = Symbol();\n\n\nexport class TrackedURLSearchParams extends URLSearchParams {\n\t#block = safe_scope();\n\t#version = tracked(0, this.#block);\n\t#url = get_current_url();\n\n\t#updating = false;\n\n\t#update_url() {\n\t\tif (!this.#url || this.#updating) return;\n\t\tthis.#updating = true;\n\n\t\tconst search = this.toString();\n\t\tthis.#url.search = search && `?${search}`;\n\n\t\tthis.#updating = false;\n\t}\n\n\t/**\n\t * @param {URLSearchParams} params\n\t * @internal\n\t */\n\t[REPLACE](params) {\n\t\tif (this.#updating) return;\n\t\tthis.#updating = true;\n\n\t\tfor (const key of [...super.keys()]) {\n\t\t\tsuper.delete(key);\n\t\t}\n\n\t\tfor (const [key, value] of params) {\n\t\t\tsuper.append(key, value);\n\t\t}\n\n\t\tincrement(this.#version);\n\t\tthis.#updating = false;\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tappend(name, value) {\n\t\tsuper.append(name, value);\n\t\tthis.#update_url();\n\t\tincrement(this.#version);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {string=} value\n\t * @returns {void}\n\t */\n\tdelete(name, value) {\n\t\tvar has_value = super.has(name, value);\n\t\tsuper.delete(name, value);\n\t\tif (has_value) {\n\t\t\tthis.#update_url();\n\t\t\tincrement(this.#version);\n\t\t}\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @returns {string|null}\n\t */\n\tget(name) {\n\t\tget(this.#version);\n\t\treturn super.get(name);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @returns {string[]}\n\t */\n\tgetAll(name) {\n\t\tget(this.#version);\n\t\treturn super.getAll(name);\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {string=} value\n\t * @returns {boolean}\n\t */\n\thas(name, value) {\n\t\tget(this.#version);\n\t\treturn super.has(name, value);\n\t}\n\n\tkeys() {\n\t\tget(this.#version);\n\t\treturn super.keys();\n\t}\n\n\t/**\n\t * @param {string} name\n\t * @param {string} value\n\t * @returns {void}\n\t */\n\tset(name, value) {\n\t\tvar previous = super.getAll(name).join('');\n\t\tsuper.set(name, value);\n\t\t// can't use has(name, value), because for something like https://svelte.dev?foo=1&bar=2&foo=3\n\t\t// if you set `foo` to 1, then foo=3 gets deleted whilst `has(\"foo\", \"1\")` returns true\n\t\tif (previous !== super.getAll(name).join('')) {\n\t\t\tthis.#update_url();\n\t\t\tincrement(this.#version);\n\t\t}\n\t}\n\n\tsort() {\n\t\tsuper.sort();\n\t\tthis.#update_url();\n\t\tincrement(this.#version);\n\t}\n\n\ttoString() {\n\t\tget(this.#version);\n\t\treturn super.toString();\n\t}\n\n\tvalues() {\n\t\tget(this.#version);\n\t\treturn super.values();\n\t}\n\n\tentries() {\n\t\tget(this.#version);\n\t\treturn super.entries();\n\t}\n\n\t[Symbol.iterator]() {\n\t\treturn this.entries();\n\t}\n\n\tget size() {\n\t\tget(this.#version);\n\t\treturn super.size;\n\t}\n}\n", "import { get, set, safe_scope, tracked } from './internal/client/runtime.js';\nimport { REPLACE, TrackedURLSearchParams } from './url-search-params.js';\n\n/** @type {TrackedURL | null} */\nlet current_url = null;\n\nexport function get_current_url() {\n\treturn current_url;\n}\n\nexport class TrackedURL extends URL {\n\t#block = safe_scope();\n\t#protocol = tracked(super.protocol, this.#block);\n\t#username = tracked(super.username, this.#block);\n\t#password = tracked(super.password, this.#block);\n\t#hostname = tracked(super.hostname, this.#block);\n\t#port = tracked(super.port, this.#block);\n\t#pathname = tracked(super.pathname, this.#block);\n\t#hash = tracked(super.hash, this.#block);\n\t#search = tracked(super.search, this.#block);\n\t#searchParams;\n\n\t/**\n\t * @param {string | URL} url\n\t * @param {string | URL} [base]\n\t */\n\tconstructor(url, base) {\n\t\turl = new URL(url, base);\n\t\tsuper(url);\n\n\t\tcurrent_url = this;\n\t\tthis.#searchParams = new TrackedURLSearchParams(url.searchParams);\n\t\tcurrent_url = null;\n\t}\n\n\tget hash() {\n\t\treturn get(this.#hash);\n\t}\n\n\tset hash(value) {\n\t\tsuper.hash = value;\n\t\tset(this.#hash, super.hash);\n\t}\n\n\tget host() {\n\t\tget(this.#hostname);\n\t\tget(this.#port);\n\t\treturn super.host;\n\t}\n\n\tset host(value) {\n\t\tsuper.host = value;\n\t\tset(this.#hostname, super.hostname);\n\t\tset(this.#port, super.port);\n\t}\n\n\tget hostname() {\n\t\treturn get(this.#hostname);\n\t}\n\n\tset hostname(value) {\n\t\tsuper.hostname = value;\n\t\tset(this.#hostname, super.hostname);\n\t}\n\n\tget href() {\n\t\tget(this.#protocol);\n\t\tget(this.#username);\n\t\tget(this.#password);\n\t\tget(this.#hostname);\n\t\tget(this.#port);\n\t\tget(this.#pathname);\n\t\tget(this.#hash);\n\t\tget(this.#search);\n\t\treturn super.href;\n\t}\n\n\tset href(value) {\n\t\tsuper.href = value;\n\t\tset(this.#protocol, super.protocol);\n\t\tset(this.#username, super.username);\n\t\tset(this.#password, super.password);\n\t\tset(this.#hostname, super.hostname);\n\t\tset(this.#port, super.port);\n\t\tset(this.#pathname, super.pathname);\n\t\tset(this.#hash, super.hash);\n\t\tset(this.#search, super.search);\n\t\tthis.#searchParams[REPLACE](super.searchParams);\n\t}\n\n\tget password() {\n\t\treturn get(this.#password);\n\t}\n\n\tset password(value) {\n\t\tsuper.password = value;\n\t\tset(this.#password, super.password);\n\t}\n\n\tget pathname() {\n\t\treturn get(this.#pathname);\n\t}\n\n\tset pathname(value) {\n\t\tsuper.pathname = value;\n\t\tset(this.#pathname, super.pathname);\n\t}\n\n\tget port() {\n\t\treturn get(this.#port);\n\t}\n\n\tset port(value) {\n\t\tsuper.port = value;\n\t\tset(this.#port, super.port);\n\t}\n\n\tget protocol() {\n\t\treturn get(this.#protocol);\n\t}\n\n\tset protocol(value) {\n\t\tsuper.protocol = value;\n\t\tset(this.#protocol, super.protocol);\n\t}\n\n\tget search() {\n\t\treturn get(this.#search);\n\t}\n\n\tset search(value) {\n\t\tsuper.search = value;\n\t\tset(this.#search, value);\n\t\tthis.#searchParams[REPLACE](super.searchParams);\n\t}\n\n\tget username() {\n\t\treturn get(this.#username);\n\t}\n\n\tset username(value) {\n\t\tsuper.username = value;\n\t\tset(this.#username, super.username);\n\t}\n\n\tget origin() {\n\t\tget(this.#protocol);\n\t\tget(this.#hostname);\n\t\tget(this.#port);\n\t\treturn super.origin;\n\t}\n\n\tget searchParams() {\n\t\treturn this.#searchParams;\n\t}\n\n\ttoString() {\n\t\treturn this.href;\n\t}\n\n\ttoJSON() {\n\t\treturn this.href;\n\t}\n}\n", "/** @import { createSubscriber } from '#public' */\nimport { untrack, queue_microtask } from './internal/client/runtime.js';\nimport { effect } from './internal/client/blocks.js'\n\n/** @type {createSubscriber} */\nexport function createSubscriber(start) {\n\tlet subscribers = 0;\n\t/** @type {(() => void) | void} */\n\tlet stop;\n\n\treturn () => {\n\t\teffect(() => {\n\t\t\tif (subscribers === 0) {\n\t\t\t\tstop = untrack(start);\n\t\t\t}\n\n\t\t\tsubscribers += 1;\n\n\t\t\treturn () => {\n\t\t\t\tqueue_microtask(() => {\n\t\t\t\t\t// Only count down after a microtask, else we would reach 0 before our own render effect reruns,\n\t\t\t\t\t// but reach 1 again when the tick callback of the prior teardown runs. That would mean we\n\t\t\t\t\t// re-subcribe unnecessarily and create a memory leak because the old subscription is never cleaned up.\n\t\t\t\t\tsubscribers -= 1;\n\n\t\t\t\t\tif (subscribers === 0) {\n\t\t\t\t\t\tstop?.();\n\t\t\t\t\t\tstop = undefined;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t};\n\t\t});\n\t};\n}\n", "export const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\nexport const IS_CONTROLLED = 1 << 2;\nexport const IS_INDEXED = 1 << 3;\nexport const TEMPLATE_SVG_NAMESPACE = 1 << 5;\nexport const TEMPLATE_MATHML_NAMESPACE = 1 << 6;\n", "/** @type {Record<string, string>} */\nexport const escaped = {\n\t'<': '\\\\u003C',\n\t'\\\\': '\\\\\\\\',\n\t'\\b': '\\\\b',\n\t'\\f': '\\\\f',\n\t'\\n': '\\\\n',\n\t'\\r': '\\\\r',\n\t'\\t': '\\\\t',\n\t'\\u2028': '\\\\u2028',\n\t'\\u2029': '\\\\u2029'\n};\n\nexport class DevalueError extends Error {\n\t/**\n\t * @param {string} message\n\t * @param {string[]} keys\n\t */\n\tconstructor(message, keys) {\n\t\tsuper(message);\n\t\tthis.name = 'DevalueError';\n\t\tthis.path = keys.join('');\n\t}\n}\n\n/** @param {any} thing */\nexport function is_primitive(thing) {\n\treturn Object(thing) !== thing;\n}\n\nconst object_proto_names = /* @__PURE__ */ Object.getOwnPropertyNames(\n\tObject.prototype\n)\n\t.sort()\n\t.join('\\0');\n\n/** @param {any} thing */\nexport function is_plain_object(thing) {\n\tconst proto = Object.getPrototypeOf(thing);\n\n\treturn (\n\t\tproto === Object.prototype ||\n\t\tproto === null ||\n\t\tObject.getPrototypeOf(proto) === null ||\n\t\tObject.getOwnPropertyNames(proto).sort().join('\\0') === object_proto_names\n\t);\n}\n\n/** @param {any} thing */\nexport function get_type(thing) {\n\treturn Object.prototype.toString.call(thing).slice(8, -1);\n}\n\n/** @param {string} char */\nfunction get_escaped_char(char) {\n\tswitch (char) {\n\t\tcase '\"':\n\t\t\treturn '\\\\\"';\n\t\tcase '<':\n\t\t\treturn '\\\\u003C';\n\t\tcase '\\\\':\n\t\t\treturn '\\\\\\\\';\n\t\tcase '\\n':\n\t\t\treturn '\\\\n';\n\t\tcase '\\r':\n\t\t\treturn '\\\\r';\n\t\tcase '\\t':\n\t\t\treturn '\\\\t';\n\t\tcase '\\b':\n\t\t\treturn '\\\\b';\n\t\tcase '\\f':\n\t\t\treturn '\\\\f';\n\t\tcase '\\u2028':\n\t\t\treturn '\\\\u2028';\n\t\tcase '\\u2029':\n\t\t\treturn '\\\\u2029';\n\t\tdefault:\n\t\t\treturn char < ' '\n\t\t\t\t? `\\\\u${char.charCodeAt(0).toString(16).padStart(4, '0')}`\n\t\t\t\t: '';\n\t}\n}\n\n/** @param {string} str */\nexport function stringify_string(str) {\n\tlet result = '';\n\tlet last_pos = 0;\n\tconst len = str.length;\n\n\tfor (let i = 0; i < len; i += 1) {\n\t\tconst char = str[i];\n\t\tconst replacement = get_escaped_char(char);\n\t\tif (replacement) {\n\t\t\tresult += str.slice(last_pos, i) + replacement;\n\t\t\tlast_pos = i + 1;\n\t\t}\n\t}\n\n\treturn `\"${last_pos === 0 ? str : result + str.slice(last_pos)}\"`;\n}\n\n/** @param {Record<string | symbol, any>} object */\nexport function enumerable_symbols(object) {\n\treturn Object.getOwnPropertySymbols(object).filter(\n\t\t(symbol) => Object.getOwnPropertyDescriptor(object, symbol).enumerable\n\t);\n}\n\nconst is_identifier = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;\n\n/** @param {string} key */\nexport function stringify_key(key) {\n\treturn is_identifier.test(key) ? '.' + key : '[' + JSON.stringify(key) + ']';\n}\n", "/** @import { Derived } from '#client' */\nimport { createSubscriber } from './create-subscriber.js';\nimport { safe_scope, derived } from './internal/client/runtime.js';\n\n/**\n * @template V\n * @constructor\n * @param {() => V} fn\n * @param {() => void | (() => void)} start\n * @returns {Derived}\n */\nexport function ReactiveValue(fn, start) {\n\tif (!new.target) {\n\t\tthrow new TypeError('`ReactiveValue` must be called with new');\n\t}\n\n\tconst s = createSubscriber(start);\n\tconst block = safe_scope();\n\n\treturn (derived(fn, block, () => { s(); return fn(); }, (_, prev) => prev));\n}\n", "import { on } from './internal/client/events.js';\nimport { get, safe_scope, set, tracked } from './internal/client/index.js';\nimport { ReactiveValue } from './reactive-value.js';\n\nconst parenthesis_regex = /\\(.+\\)/;\nconst non_parenthesized_keywords = new Set(['all', 'print', 'screen', 'and', 'or', 'not', 'only']);\n\n/**\n * @constructor\n * @param {string} query\n * @param {boolean | undefined} [fallback]\n * @returns {ReactiveValue<boolean>}\n */\nexport function MediaQuery(query, fallback) {\n\tif (!new.target) {\n\t\tthrow new TypeError('MediaQuery must be called with new');\n\t}\n\n\tvar block = safe_scope();\n\n\tlet final_query =\n\t\tparenthesis_regex.test(query) ||\n\t\t\t// we need to use `some` here because technically this `window.matchMedia('random,screen')` still returns true\n\t\t\tquery.split(/[\\s,]+/).some((keyword) => non_parenthesized_keywords.has(keyword.trim()))\n\t\t\t? query\n\t\t\t: `(${query})`;\n\tconst q = window.matchMedia(final_query);\n\tconst matches = tracked(q.matches, block);\n\n\treturn new ReactiveValue(\n\t\t() => get(matches),\n\t\t() => on(q, 'change', () => {\n\t\t\t// skip wrapping in untrack as createSubscriber already does it\n\t\t\tif (q.matches !== get(matches)) {\n\t\t\t\tset(matches, q.matches)\n\t\t\t}\n\t\t})\n\t);\n}\n", "/** @import { Block } from '#client' */\n\nimport { branch, destroy_block, remove_block_dom, render } from './blocks.js';\nimport { UNINITIALIZED } from './constants.js';\nimport { handle_root_events } from './events.js';\nimport { create_text } from './operations.js';\nimport { active_block } from './runtime.js';\n\n/**\n * @param {any} _\n * @param {{ target: Element, children: (anchor: Node, props: {}, block: Block) => void }} props\n * @returns {void}\n */\nexport function Portal(_, props) {\n\t/** @type {Element | symbol} */\n\tlet target = UNINITIALIZED;\n\t/** @type {((anchor: Node, props: {}, block: Block) => void) | symbol} */\n\tlet children = UNINITIALIZED;\n\t/** @type {Block | null} */\n\tvar b = null;\n\t/** @type {Text | null} */\n\tvar anchor = null;\n\t/** @type {Node | null} */\n\tvar dom_start = null;\n\t/** @type {Node | null} */\n\tvar dom_end = null;\n\n\trender(() => {\n\t\tif (target === (target = props.target)) return;\n\t\tif (children === (children = props.children)) return;\n\n\t\tif (b !== null) {\n\t\t\tdestroy_block(b);\n\t\t}\n\n\t\tif (anchor !== null) {\n\t\t\tanchor.remove();\n\t\t}\n\n\t\tdom_start = dom_end = null;\n\n\t\tanchor = create_text();\n\t\t/** @type {Element} */ (target).append(anchor);\n\n\t\tconst cleanup_events = handle_root_events(/** @type {Element} */ (target));\n\n\t\tvar block = /** @type {Block} */ (active_block);\n\n\t\tb = branch(() => {\n\t\t\tif (typeof children === 'function') {\n\t\t\t\tchildren(/** @type {Text} */ (anchor), {}, block);\n\t\t\t}\n\t\t});\n\n\t\tdom_start = b?.s?.start;\n\t\tdom_end = b?.s?.end;\n\n\t\treturn () => {\n\t\t\tcleanup_events();\n\t\t\t/** @type {Text} */ (anchor).remove();\n\t\t\tif (dom_start && dom_end) {\n\t\t\t\tremove_block_dom(dom_start, dom_end);\n\t\t\t}\n\t\t};\n\t});\n}\n", "/** @import { Tracked } from '#client' */\n\nimport { effect, render } from './blocks.js';\nimport { on } from './events.js';\nimport { get, set, tick, untrack } from './runtime.js';\nimport { is_array, is_tracked_object } from './utils.js';\n\n/**\n * @param {string} name\n * @returns {TypeError}\n */\nfunction not_tracked_type_error(name) {\n\treturn new TypeError(`${name} argument is not a tracked object`);\n}\n\n/**\n * Resize observer singleton.\n * One listener per element only!\n * https://groups.google.com/a/chromium.org/g/blink-dev/c/z6ienONUb5A/m/F5-VcUZtBAAJ\n */\nclass ResizeObserverSingleton {\n\t/** */\n\t#listeners = new WeakMap();\n\n\t/** @type {ResizeObserver | undefined} */\n\t#observer;\n\n\t/** @type {ResizeObserverOptions} */\n\t#options;\n\n\t/** @static */\n\tstatic entries = new WeakMap();\n\n\t/** @param {ResizeObserverOptions} options */\n\tconstructor(options) {\n\t\tthis.#options = options;\n\t}\n\n\t/**\n\t * @param {Element} element\n\t * @param {(entry: ResizeObserverEntry) => any} listener\n\t */\n\tobserve(element, listener) {\n\t\tvar listeners = this.#listeners.get(element) || new Set();\n\t\tlisteners.add(listener);\n\n\t\tthis.#listeners.set(element, listeners);\n\t\tthis.#getObserver().observe(element, this.#options);\n\n\t\treturn () => {\n\t\t\tvar listeners = this.#listeners.get(element);\n\t\t\tlisteners.delete(listener);\n\n\t\t\tif (listeners.size === 0) {\n\t\t\t\tthis.#listeners.delete(element);\n\t\t\t\t/** @type {ResizeObserver} */ (this.#observer).unobserve(element);\n\t\t\t}\n\t\t};\n\t}\n\n\t#getObserver() {\n\t\treturn (\n\t\t\tthis.#observer ??\n\t\t\t(this.#observer = new ResizeObserver(\n\t\t\t\t/** @param {any} entries */ (entries) => {\n\t\t\t\t\tfor (var entry of entries) {\n\t\t\t\t\t\tResizeObserverSingleton.entries.set(entry.target, entry);\n\t\t\t\t\t\tfor (var listener of this.#listeners.get(entry.target) || []) {\n\t\t\t\t\t\t\tlistener(entry);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t))\n\t\t);\n\t}\n}\n\nvar resize_observer_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'content-box',\n});\n\nvar resize_observer_border_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'border-box',\n});\n\nvar resize_observer_device_pixel_content_box = /* @__PURE__ */ new ResizeObserverSingleton({\n\tbox: 'device-pixel-content-box',\n});\n\n/**\n * @param {string} value\n */\nfunction to_number(value) {\n\treturn value === '' ? null : +value;\n}\n\n/**\n * @param {HTMLInputElement} input\n */\nfunction is_numberlike_input(input) {\n\tvar type = input.type;\n\treturn type === 'number' || type === 'range';\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\treturn option.value;\n}\n\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n * @param {boolean} mounting\n */\nfunction select_option(select, value, mounting = false) {\n\tif (select.multiple) {\n\t\t// If value is null or undefined, keep the selection as is\n\t\tif (value == undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\t// If not an array, warn and keep the selection as is\n\t\tif (!is_array(value)) {\n\t\t\t// TODO\n\t\t}\n\n\t\t// Otherwise, update the selection\n\t\tfor (var option of select.options) {\n\t\t\toption.selected = /** @type {string[]} */ (value).includes(get_option_value(option));\n\t\t}\n\n\t\treturn;\n\t}\n\n\tfor (option of select.options) {\n\t\tvar option_value = get_option_value(option);\n\t\tif (option_value === value) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLInputElement | HTMLSelectElement) => void}\n */\nexport function bindValue(maybe_tracked) {\n\tif (!is_tracked_object(maybe_tracked)) {\n\t\tthrow not_tracked_type_error('bindValue()');\n\t}\n\n\tvar tracked = /** @type {Tracked} */ (maybe_tracked);\n\n\treturn (node) => {\n\t\tvar clear_event;\n\n\t\tif (node.tagName === 'SELECT') {\n\t\t\tvar select = /** @type {HTMLSelectElement} */ (node);\n\t\t\tvar mounting = true;\n\n\t\t\tclear_event = on(select, 'change', async () => {\n\t\t\t\tvar query = ':checked';\n\t\t\t\t/** @type {unknown} */\n\t\t\t\tvar value;\n\n\t\t\t\tif (select.multiple) {\n\t\t\t\t\tvalue = [].map.call(select.querySelectorAll(query), get_option_value);\n\t\t\t\t} else {\n\t\t\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tvar selected_option =\n\t\t\t\t\t\tselect.querySelector(query) ??\n\t\t\t\t\t\t// will fall back to first non-disabled option if no option is selected\n\t\t\t\t\t\tselect.querySelector('option:not([disabled])');\n\t\t\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t\t\t}\n\n\t\t\t\tset(tracked, value);\n\t\t\t});\n\n\t\t\teffect(() => {\n\t\t\t\tvar value = get(tracked);\n\t\t\t\tselect_option(select, value, mounting);\n\n\t\t\t\t// Mounting and value undefined -> take selection from dom\n\t\t\t\tif (mounting && value === undefined) {\n\t\t\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\t\t\tif (selected_option !== null) {\n\t\t\t\t\t\tvalue = get_option_value(selected_option);\n\t\t\t\t\t\tset(tracked, value);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tmounting = false;\n\t\t\t});\n\t\t} else {\n\t\t\tvar input = /** @type {HTMLInputElement} */ (node);\n\n\t\t\tclear_event = on(input, 'input', async () => {\n\t\t\t\t/** @type {any} */\n\t\t\t\tvar value = input.value;\n\t\t\t\tvalue = is_numberlike_input(input) ? to_number(value) : value;\n\t\t\t\tset(tracked, value);\n\n\t\t\t\tawait tick();\n\n\t\t\t\tif (value !== (value = get(tracked))) {\n\t\t\t\t\tvar start = input.selectionStart;\n\t\t\t\t\tvar end = input.selectionEnd;\n\t\t\t\t\tinput.value = value ?? '';\n\n\t\t\t\t\t// Restore selection\n\t\t\t\t\tif (end !== null) {\n\t\t\t\t\t\tinput.selectionStart = start;\n\t\t\t\t\t\tinput.selectionEnd = Math.min(end, input.value.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\trender(() => {\n\t\t\t\tvar value = get(tracked);\n\n\t\t\t\tif (is_numberlike_input(input) && value === to_number(input.value)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (input.type === 'date' && !value && !input.value) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (value !== input.value) {\n\t\t\t\t\tinput.value = value ?? '';\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn clear_event;\n\t\t}\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLInputElement) => void}\n */\nexport function bindChecked(maybe_tracked) {\n\tif (!is_tracked_object(maybe_tracked)) {\n\t\tthrow not_tracked_type_error('bindChecked()');\n\t}\n\n\tconst tracked = /** @type {Tracked} */ (maybe_tracked);\n\n\treturn (input) => {\n\t\tconst clear_event = on(input, 'change', () => {\n\t\t\tset(tracked, input.checked);\n\t\t});\n\n\t\treturn clear_event;\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {'clientWidth' | 'clientHeight' | 'offsetWidth' | 'offsetHeight'} type\n */\nfunction bind_element_size(maybe_tracked, type) {\n\tif (!is_tracked_object(maybe_tracked)) {\n\t\tthrow not_tracked_type_error(`bind${type.charAt(0).toUpperCase() + type.slice(1)}()`);\n\t}\n\n\tvar tracked = /** @type {Tracked<any>} */ (maybe_tracked);\n\n\treturn (/** @type {HTMLElement} */ element) => {\n\t\tvar unsubscribe = resize_observer_border_box.observe(element, () =>\n\t\t\tset(tracked, element[type]),\n\t\t);\n\n\t\teffect(() => {\n\t\t\tuntrack(() => set(tracked, element[type]));\n\t\t\treturn unsubscribe;\n\t\t});\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindClientWidth(maybe_tracked) {\n\treturn bind_element_size(maybe_tracked, 'clientWidth');\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindClientHeight(maybe_tracked) {\n\treturn bind_element_size(maybe_tracked, 'clientHeight');\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindOffsetWidth(maybe_tracked) {\n\treturn bind_element_size(maybe_tracked, 'offsetWidth');\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindOffsetHeight(maybe_tracked) {\n\treturn bind_element_size(maybe_tracked, 'offsetHeight');\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {'contentRect' | 'contentBoxSize' | 'borderBoxSize' | 'devicePixelContentBoxSize'} type\n */\nfunction bind_element_rect(maybe_tracked, type) {\n\tif (!is_tracked_object(maybe_tracked)) {\n\t\tthrow not_tracked_type_error(`bind${type.charAt(0).toUpperCase() + type.slice(1)}()`);\n\t}\n\n\tvar tracked = /** @type {Tracked<any>} */ (maybe_tracked);\n\tvar observer =\n\t\ttype === 'contentRect' || type === 'contentBoxSize'\n\t\t\t? resize_observer_content_box\n\t\t\t: type === 'borderBoxSize'\n\t\t\t\t? resize_observer_border_box\n\t\t\t\t: resize_observer_device_pixel_content_box;\n\n\treturn (/** @type {HTMLElement} */ element) => {\n\t\tvar unsubscribe = observer.observe(\n\t\t\telement,\n\t\t\t/** @param {any} entry */ (entry) => set(tracked, entry[type]),\n\t\t);\n\n\t\teffect(() => unsubscribe);\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindContentRect(maybe_tracked) {\n\treturn bind_element_rect(maybe_tracked, 'contentRect');\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindContentBoxSize(maybe_tracked) {\n\treturn bind_element_rect(maybe_tracked, 'contentBoxSize');\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindBorderBoxSize(maybe_tracked) {\n\treturn bind_element_rect(maybe_tracked, 'borderBoxSize');\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindDevicePixelContentBoxSize(maybe_tracked) {\n\treturn bind_element_rect(maybe_tracked, 'devicePixelContentBoxSize');\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @param {'innerHTML' | 'innerText' | 'textContent'} property\n * @returns {(node: HTMLElement) => void}\n */\nexport function bind_content_editable(maybe_tracked, property) {\n\tif (!is_tracked_object(maybe_tracked)) {\n\t\tthrow not_tracked_type_error(`bind${property.charAt(0).toUpperCase() + property.slice(1)}()`);\n\t}\n\n\tconst tracked = /** @type {Tracked} */ (maybe_tracked);\n\n\treturn (element) => {\n\t\tconst clear_event = on(element, 'input', () => {\n\t\t\tset(tracked, element[property]);\n\t\t});\n\n\t\trender(() => {\n\t\t\tvar value = get(tracked);\n\n\t\t\tif (element[property] !== value) {\n\t\t\t\tif (value == null) {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tvar non_null_value = element[property];\n\t\t\t\t\tset(tracked, non_null_value);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[property] = value + '';\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn clear_event;\n\t};\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindInnerHTML(maybe_tracked) {\n\treturn bind_content_editable(maybe_tracked, 'innerHTML');\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindInnerText(maybe_tracked) {\n\treturn bind_content_editable(maybe_tracked, 'innerText');\n}\n\n/**\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindTextContent(maybe_tracked) {\n\treturn bind_content_editable(maybe_tracked, 'textContent');\n}\n\n/**\n * Syntactic sugar for binding a HTMLElement with {ref fn}\n * @param {unknown} maybe_tracked\n * @returns {(node: HTMLElement) => void}\n */\nexport function bindNode(maybe_tracked) {\n\tif (!is_tracked_object(maybe_tracked)) {\n\t\tthrow not_tracked_type_error('bindNode()');\n\t}\n\n\tconst tracked = /** @type {Tracked} */ (maybe_tracked);\n\n\t/** @param {HTMLElement} node */\n\treturn (node) => {\n\t\tset(tracked, node);\n\t};\n}\n", "/** @import { Block, CompatOptions } from '#client' */\n\nimport { destroy_block, root } from './internal/client/blocks.js';\nimport { handle_root_events } from './internal/client/events.js';\nimport { init_operations } from './internal/client/operations.js';\nimport { active_block } from './internal/client/runtime.js';\nimport { create_anchor } from './internal/client/utils.js';\nimport { remove_ssr_css } from './internal/client/css.js';\n\n// Re-export JSX runtime functions for jsxImportSource: \"ripple\"\nexport { jsx, jsxs, Fragment } from '../jsx-runtime.js';\n\n/**\n * @param {(anchor: Node, props: Record<string, any>, active_block: Block | null) => void} component\n * @param {{ props?: Record<string, any>, target: HTMLElement, compat?: CompatOptions }} options\n * @returns {() => void}\n */\nexport function mount(component, options) {\n\tinit_operations();\n\tremove_ssr_css();\n\n\tconst props = options.props || {};\n\tconst target = options.target;\n\tconst anchor = create_anchor();\n\n\t// Clear target content in case of SSR\n\tif (target.firstChild) {\n\t\ttarget.textContent = '';\n\t}\n\n\ttarget.append(anchor);\n\n\tconst cleanup_events = handle_root_events(target);\n\n\tconst _root = root(() => {\n\t\tcomponent(anchor, props, active_block);\n\t}, options.compat);\n\n\treturn () => {\n\t\tcleanup_events();\n\t\tdestroy_block(_root);\n\t};\n}\n\nexport { Context } from './internal/client/context.js';\n\nexport {\n\tflush_sync as flushSync,\n\ttrack,\n\ttrack_split as trackSplit,\n\tuntrack,\n\ttick,\n} from './internal/client/runtime.js';\n\nexport { TrackedArray } from './array.js';\n\nexport { TrackedObject } from './object.js';\n\nexport { TrackedSet } from './set.js';\n\nexport { TrackedMap } from './map.js';\n\nexport { TrackedDate } from './date.js';\n\nexport { TrackedURL } from './url.js';\n\nexport { TrackedURLSearchParams } from './url-search-params.js';\n\nexport { createSubscriber } from './create-subscriber.js';\n\nexport { MediaQuery } from './media-query.js';\n\nexport { user_effect as effect } from './internal/client/blocks.js';\n\nexport { Portal } from './internal/client/portal.js';\n\nexport { ref_prop as createRefKey, get, public_set as set } from './internal/client/runtime.js';\n\nexport { on } from './internal/client/events.js';\n\nexport {\n\tbindValue,\n\tbindChecked,\n\tbindClientWidth,\n\tbindClientHeight,\n\tbindContentRect,\n\tbindContentBoxSize,\n\tbindBorderBoxSize,\n\tbindDevicePixelContentBoxSize,\n\tbindInnerHTML,\n\tbindInnerText,\n\tbindTextContent,\n\tbindNode,\n} from './internal/client/bindings.js';\n"],
  "mappings": "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",
  "names": ["document", "document", "block", "block", "block", "get", "set", "tracked", "tracking", "effect", "block", "tracked", "get", "set", "tracked", "event", "block", "block", "block", "block", "value", "t", "key", "block", "block", "block", "introspect_methods", "init", "_tracked_size", "_tracked_items", "_block", "init_fn", "block", "init", "_block", "init_fn", "block", "_block", "_block", "block", "fallback", "block", "block", "listeners", "maybe_tracked", "tracked", "maybe_tracked", "tracked"]
}
