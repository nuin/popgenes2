import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __publicField
} from "./chunk-RGIOIEUU.js";

// node_modules/ripple/src/runtime/internal/client/constants.js
var ROOT_BLOCK = 1 << 1;
var RENDER_BLOCK = 1 << 2;
var EFFECT_BLOCK = 1 << 3;
var BRANCH_BLOCK = 1 << 4;
var FOR_BLOCK = 1 << 5;
var TRY_BLOCK = 1 << 6;
var IF_BLOCK = 1 << 7;
var SWITCH_BLOCK = 1 << 8;
var COMPOSITE_BLOCK = 1 << 9;
var ASYNC_BLOCK = 1 << 10;
var HEAD_BLOCK = 1 << 11;
var CONTAINS_UPDATE = 1 << 12;
var CONTAINS_TEARDOWN = 1 << 13;
var BLOCK_HAS_RUN = 1 << 14;
var TRACKED = 1 << 15;
var DERIVED = 1 << 16;
var DEFERRED = 1 << 17;
var PAUSED = 1 << 18;
var DESTROYED = 1 << 19;
var CONTROL_FLOW_BLOCK = FOR_BLOCK | IF_BLOCK | SWITCH_BLOCK | TRY_BLOCK | COMPOSITE_BLOCK;
var UNINITIALIZED = Symbol();
var TRACKED_ARRAY = Symbol();
var TRACKED_OBJECT = Symbol();
var COMPUTED_PROPERTY = Symbol();
var REF_PROP = "ref";
var ARRAY_SET_INDEX_AT = Symbol();
var MAX_ARRAY_LENGTH = 2 ** 32 - 1;

// node_modules/ripple/src/runtime/internal/client/utils.js
var get_descriptor = Object.getOwnPropertyDescriptor;
var array_from = Array.from;
var is_array = Array.isArray;
var define_property = Object.defineProperty;
var get_prototype_of = Object.getPrototypeOf;
var structured_clone = structuredClone;
var object_prototype = Object.prototype;
var array_prototype = Array.prototype;
function create_anchor() {
  var t = document.createTextNode("");
  t.__t = "";
  return t;
}
function is_tracked_object(v) {
  return typeof v === "object" && v !== null && typeof /** @type {any} */
  v.f === "number";
}

// node_modules/ripple/src/runtime/internal/client/operations.js
var first_child_getter;
var next_sibling_getter;
var document2;
var is_firefox;
function init_operations() {
  var node_prototype = Node.prototype;
  var element_prototype = Element.prototype;
  var event_target_prototype = EventTarget.prototype;
  is_firefox = /Firefox/.test(navigator.userAgent);
  document2 = window.document;
  first_child_getter = get_descriptor(node_prototype, "firstChild").get;
  next_sibling_getter = get_descriptor(node_prototype, "nextSibling").get;
  element_prototype.__click = void 0;
  event_target_prototype.__root = void 0;
}
function next_sibling(node) {
  return next_sibling_getter.call(node);
}
function create_text(value = "") {
  return document2.createTextNode(value);
}

// node_modules/ripple/src/utils/events.js
var PASSIVE_EVENTS = ["touchstart", "touchmove"];
function is_passive_event(name) {
  return PASSIVE_EVENTS.includes(name);
}

// node_modules/esm-env/true.js
var true_default = true;

// node_modules/ripple/src/runtime/internal/client/runtime.js
var FLUSH_MICROTASK = 0;
var FLUSH_SYNC = 1;
var active_block = null;
var active_reaction = null;
var active_scope = null;
var active_component = null;
var is_mutating_allowed = true;
var old_values = /* @__PURE__ */ new Map();
var scheduler_mode = FLUSH_MICROTASK;
var is_micro_task_queued = false;
var clock = 0;
var queued_root_blocks = [];
var queued_microtasks = [];
var flush_count = 0;
var active_dependency = null;
var tracking = false;
var teardown = false;
function increment_clock() {
  return ++clock;
}
function set_active_block(block2) {
  active_block = block2;
}
function set_active_reaction(reaction) {
  active_reaction = reaction;
}
function set_tracking(value) {
  tracking = value;
}
function run_teardown(block2) {
  var fn = block2.t;
  if (fn !== null) {
    var previous_block = active_block;
    var previous_reaction = active_reaction;
    var previous_tracking = tracking;
    var previous_teardown = teardown;
    try {
      active_block = null;
      active_reaction = null;
      tracking = false;
      teardown = true;
      fn.call(null);
    } finally {
      active_block = previous_block;
      active_reaction = previous_reaction;
      tracking = previous_tracking;
      teardown = previous_teardown;
    }
  }
}
function update_derived(computed) {
  var value = computed.__v;
  if (value === UNINITIALIZED || is_tracking_dirty(computed.d)) {
    value = run_derived(computed);
    if (value !== computed.__v) {
      computed.__v = value;
      computed.c = increment_clock();
    }
  }
}
function destroy_computed_children(computed) {
  var blocks = computed.blocks;
  if (blocks !== null) {
    computed.blocks = null;
    for (var i = 0; i < blocks.length; i++) {
      destroy_block(blocks[i]);
    }
  }
}
function run_derived(computed) {
  var previous_block = active_block;
  var previous_reaction = active_reaction;
  var previous_tracking = tracking;
  var previous_dependency = active_dependency;
  var previous_component = active_component;
  var previous_is_mutating_allowed = is_mutating_allowed;
  try {
    active_block = computed.b;
    active_reaction = computed;
    tracking = true;
    active_dependency = null;
    active_component = computed.co;
    is_mutating_allowed = false;
    destroy_computed_children(computed);
    var value = computed.fn();
    computed.d = active_dependency;
    return value;
  } finally {
    active_block = previous_block;
    active_reaction = previous_reaction;
    tracking = previous_tracking;
    active_dependency = previous_dependency;
    active_component = previous_component;
    is_mutating_allowed = previous_is_mutating_allowed;
  }
}
function handle_error(error, block2) {
  var current = block2;
  while (current !== null) {
    var state = current.s;
    if ((current.f & TRY_BLOCK) !== 0 && state.c !== null) {
      state.c(error);
      return;
    }
    current = current.p;
  }
  throw error;
}
function run_block(block2) {
  var previous_block = active_block;
  var previous_reaction = active_reaction;
  var previous_tracking = tracking;
  var previous_dependency = active_dependency;
  var previous_component = active_component;
  try {
    active_block = block2;
    active_reaction = block2;
    active_component = block2.co;
    destroy_non_branch_children(block2);
    run_teardown(block2);
    tracking = (block2.f & (ROOT_BLOCK | BRANCH_BLOCK)) === 0;
    active_dependency = null;
    var res = block2.fn(block2.s);
    if (typeof res === "function") {
      block2.t = res;
      let current = block2;
      while (current !== null && (current.f & CONTAINS_TEARDOWN) === 0) {
        current.f ^= CONTAINS_TEARDOWN;
        current = current.p;
      }
    }
    block2.d = active_dependency;
  } catch (error) {
    handle_error(error, block2);
  } finally {
    active_block = previous_block;
    active_reaction = previous_reaction;
    tracking = previous_tracking;
    active_dependency = previous_dependency;
    active_component = previous_component;
  }
}
var empty_get_set = { get: void 0, set: void 0 };
function tracked(v, block2, get2, set2) {
  if (true_default) {
    return {
      DO_NOT_ACCESS_THIS_OBJECT_DIRECTLY: true,
      a: get2 || set2 ? { get: get2, set: set2 } : empty_get_set,
      b: block2 || active_block,
      c: 0,
      f: TRACKED,
      __v: v
    };
  }
  return {
    a: get2 || set2 ? { get: get2, set: set2 } : empty_get_set,
    b: block2 || active_block,
    c: 0,
    f: TRACKED,
    __v: v
  };
}
function derived(fn, block2, get2, set2) {
  if (true_default) {
    return {
      DO_NOT_ACCESS_THIS_OBJECT_DIRECTLY: true,
      a: get2 || set2 ? { get: get2, set: set2 } : empty_get_set,
      b: block2 || active_block,
      blocks: null,
      c: 0,
      co: active_component,
      d: null,
      f: TRACKED | DERIVED,
      fn,
      __v: UNINITIALIZED
    };
  }
  return {
    a: get2 || set2 ? { get: get2, set: set2 } : empty_get_set,
    b: block2 || active_block,
    blocks: null,
    c: 0,
    co: active_component,
    d: null,
    f: TRACKED | DERIVED,
    fn,
    __v: UNINITIALIZED
  };
}
function track(v, get2, set2, b) {
  if (is_tracked_object(v)) {
    return v;
  }
  if (b === null) {
    throw new TypeError("track() requires a valid component context");
  }
  if (typeof v === "function") {
    return derived(v, b, get2, set2);
  }
  return tracked(v, b, get2, set2);
}
function track_split(v, l, b) {
  var is_tracked = is_tracked_object(v);
  if (is_tracked || typeof v !== "object" || v === null || is_array(v)) {
    throw new TypeError("Invalid value: expected a non-tracked object");
  }
  var out = [];
  var rest = {};
  var done = {};
  var props = Reflect.ownKeys(v);
  for (let i = 0, key, t; i < l.length; i++) {
    key = l[i];
    if (props.includes(key)) {
      if (is_tracked_object(v[key])) {
        t = v[key];
      } else {
        t = tracked(void 0, b);
        t = define_property(
          t,
          "__v",
          /** @type {PropertyDescriptor} */
          get_descriptor(v, key)
        );
      }
    } else {
      t = tracked(void 0, b);
    }
    out[i] = t;
    done[key] = 1;
  }
  for (let i = 0, key; i < props.length; i++) {
    key = props[i];
    if (done[key]) {
      continue;
    }
    define_property(
      rest,
      key,
      /** @type {PropertyDescriptor} */
      get_descriptor(v, key)
    );
  }
  out.push(tracked(rest, b));
  return out;
}
function create_dependency(tracked2) {
  var reaction = (
    /** @type {Derived | Block} **/
    active_reaction
  );
  var existing = reaction.d;
  if (existing !== null) {
    reaction.d = existing.n;
    existing.c = tracked2.c;
    existing.t = tracked2;
    existing.n = null;
    return existing;
  }
  return {
    c: tracked2.c,
    t: tracked2,
    n: null
  };
}
function is_tracking_dirty(tracking2) {
  if (tracking2 === null) {
    return false;
  }
  while (tracking2 !== null) {
    var tracked2 = tracking2.t;
    if ((tracked2.f & DERIVED) !== 0) {
      update_derived(
        /** @type {Derived} **/
        tracked2
      );
    }
    if (tracked2.c > tracking2.c) {
      return true;
    }
    tracking2 = tracking2.n;
  }
  return false;
}
function is_block_dirty(block2) {
  var flags = block2.f;
  if ((flags & (ROOT_BLOCK | BRANCH_BLOCK)) !== 0) {
    return false;
  }
  if ((flags & BLOCK_HAS_RUN) === 0) {
    block2.f ^= BLOCK_HAS_RUN;
    return true;
  }
  return is_tracking_dirty(block2.d);
}
function trigger_track_get(fn, v) {
  var previous_is_mutating_allowed = is_mutating_allowed;
  try {
    is_mutating_allowed = false;
    return untrack(() => fn(v));
  } finally {
    is_mutating_allowed = previous_is_mutating_allowed;
  }
}
function flush_updates(root_block) {
  var current = root_block;
  var containing_update = null;
  var effects = [];
  while (current !== null) {
    var flags = current.f;
    if ((flags & CONTAINS_UPDATE) !== 0) {
      current.f ^= CONTAINS_UPDATE;
      containing_update = current;
    }
    if ((flags & PAUSED) === 0 && containing_update !== null) {
      if ((flags & EFFECT_BLOCK) !== 0) {
        effects.push(current);
      } else {
        try {
          if (is_block_dirty(current)) {
            run_block(current);
          }
        } catch (error) {
          handle_error(error, current);
        }
      }
      var child = current.first;
      if (child !== null) {
        current = child;
        continue;
      }
    }
    var parent = current.p;
    current = current.next;
    while (current === null && parent !== null) {
      if (parent === containing_update) {
        containing_update = null;
      }
      current = parent.next;
      parent = parent.p;
    }
  }
  var length = effects.length;
  for (var i = 0; i < length; i++) {
    var effect2 = effects[i];
    var flags = effect2.f;
    try {
      if ((flags & (PAUSED | DESTROYED)) === 0 && is_block_dirty(effect2)) {
        run_block(effect2);
      }
    } catch (error) {
      handle_error(error, effect2);
    }
  }
}
function flush_queued_root_blocks(root_blocks) {
  for (let i = 0; i < root_blocks.length; i++) {
    flush_updates(root_blocks[i]);
  }
}
async function tick() {
  return new Promise((f) => requestAnimationFrame(() => f()));
}
function flush_microtasks() {
  is_micro_task_queued = false;
  if (queued_microtasks.length > 0) {
    var microtasks = queued_microtasks;
    queued_microtasks = [];
    for (var i = 0; i < microtasks.length; i++) {
      microtasks[i]();
    }
  }
  if (flush_count > 1001) {
    return;
  }
  var previous_queued_root_blocks = queued_root_blocks;
  queued_root_blocks = [];
  flush_queued_root_blocks(previous_queued_root_blocks);
  if (!is_micro_task_queued) {
    flush_count = 0;
  }
  old_values.clear();
}
function queue_microtask(fn) {
  if (!is_micro_task_queued) {
    is_micro_task_queued = true;
    queueMicrotask(flush_microtasks);
  }
  if (fn !== void 0) {
    queued_microtasks.push(fn);
  }
}
function schedule_update(block2) {
  if (scheduler_mode === FLUSH_MICROTASK) {
    queue_microtask();
  }
  let current = block2;
  while (current !== null) {
    var flags = current.f;
    if ((flags & CONTAINS_UPDATE) !== 0) return;
    current.f ^= CONTAINS_UPDATE;
    if ((flags & ROOT_BLOCK) !== 0) {
      break;
    }
    current = /** @type {Block} */
    current.p;
  }
  queued_root_blocks.push(current);
}
function register_dependency(tracked2) {
  var dependency = active_dependency;
  if (dependency === null) {
    dependency = create_dependency(tracked2);
    active_dependency = dependency;
  } else {
    var current = dependency;
    while (current !== null) {
      if (current.t === tracked2) {
        current.c = tracked2.c;
        return;
      }
      var next = current.n;
      if (next === null) {
        break;
      }
      current = next;
    }
    dependency = create_dependency(tracked2);
    current.n = dependency;
  }
}
function get_derived(computed) {
  update_derived(computed);
  if (tracking) {
    register_dependency(computed);
  }
  var get2 = computed.a.get;
  if (get2 !== void 0) {
    computed.__v = trigger_track_get(get2, computed.__v);
  }
  return computed.__v;
}
function get(tracked2) {
  if (!is_tracked_object(tracked2)) {
    return tracked2;
  }
  return (tracked2.f & DERIVED) !== 0 ? get_derived(
    /** @type {Derived} */
    tracked2
  ) : get_tracked(tracked2);
}
function get_tracked(tracked2) {
  var value = tracked2.__v;
  if (tracking) {
    register_dependency(tracked2);
  }
  if (teardown && old_values.has(tracked2)) {
    value = old_values.get(tracked2);
  }
  var get2 = tracked2.a.get;
  if (get2 !== void 0) {
    value = trigger_track_get(get2, value);
  }
  return value;
}
function public_set(tracked2, value) {
  set(tracked2, value);
}
function set(tracked2, value) {
  if (!is_mutating_allowed) {
    throw new Error(
      'Assignments or updates to tracked values are not allowed during computed "track(() => ...)" evaluation'
    );
  }
  var old_value = tracked2.__v;
  if (value !== old_value) {
    var tracked_block = tracked2.b;
    if ((tracked_block.f & CONTAINS_TEARDOWN) !== 0) {
      if (teardown) {
        old_values.set(tracked2, value);
      } else {
        old_values.set(tracked2, old_value);
      }
    }
    let set2 = tracked2.a.set;
    if (set2 !== void 0) {
      value = untrack(() => set2(value, old_value));
    }
    tracked2.__v = value;
    tracked2.c = increment_clock();
    schedule_update(tracked_block);
  }
}
function untrack(fn) {
  var previous_tracking = tracking;
  var previous_dependency = active_dependency;
  tracking = false;
  active_dependency = null;
  try {
    return fn();
  } finally {
    tracking = previous_tracking;
    active_dependency = previous_dependency;
  }
}
function flush_sync(fn) {
  var previous_scheduler_mode = scheduler_mode;
  var previous_queued_root_blocks = queued_root_blocks;
  try {
    var root_blocks = [];
    scheduler_mode = FLUSH_SYNC;
    queued_root_blocks = root_blocks;
    is_micro_task_queued = false;
    flush_queued_root_blocks(previous_queued_root_blocks);
    var result = fn == null ? void 0 : fn();
    if (queued_root_blocks.length > 0 || root_blocks.length > 0) {
      flush_sync();
    }
    flush_count = 0;
    return (
      /** @type {T} */
      result
    );
  } finally {
    scheduler_mode = previous_scheduler_mode;
    queued_root_blocks = previous_queued_root_blocks;
  }
}
function increment(tracked2) {
  set(tracked2, tracked2.__v + 1);
}
function safe_scope(err = "Cannot access outside of a component context") {
  if (active_scope === null) {
    throw new Error(err);
  }
  return (
    /** @type {Block} */
    active_scope
  );
}
function create_component_ctx() {
  return {
    c: null,
    e: null,
    m: false,
    p: active_component
  };
}
function ref_prop() {
  return Symbol(REF_PROP);
}

// node_modules/ripple/src/runtime/internal/client/events.js
var all_registered_events = /* @__PURE__ */ new Set();
var root_event_handles = /* @__PURE__ */ new Set();
function on(element, type, handler, options = {}) {
  var target_handler = create_event(type.toLowerCase(), element, handler, options);
  return () => {
    element.removeEventListener(type, target_handler, options);
  };
}
var last_propagated_event = null;
function handle_event_propagation(event2) {
  var _a;
  var handler_element = this;
  var owner_document = (
    /** @type {Node} */
    handler_element.ownerDocument
  );
  var event_name = event2.type;
  var path = ((_a = event2.composedPath) == null ? void 0 : _a.call(event2)) || [];
  var current_target = (
    /** @type {null | Element} */
    path[0] || event2.target
  );
  last_propagated_event = event2;
  var path_idx = 0;
  var handled_at = last_propagated_event === event2 && event2.__root;
  if (handled_at) {
    var at_idx = path.indexOf(handled_at);
    if (at_idx !== -1 && (handler_element === document || handler_element === /** @type {any} */
    window)) {
      event2.__root = handler_element;
      return;
    }
    var handler_idx = path.indexOf(handler_element);
    if (handler_idx === -1) {
      return;
    }
    if (at_idx <= handler_idx) {
      path_idx = at_idx;
    }
  }
  current_target = /** @type {Element} */
  path[path_idx] || event2.target;
  if (current_target === handler_element) return;
  define_property(event2, "currentTarget", {
    configurable: true,
    get() {
      return current_target || owner_document;
    }
  });
  var previous_block = active_block;
  var previous_reaction = active_reaction;
  var previous_tracking = tracking;
  set_active_block(null);
  set_active_reaction(null);
  set_tracking(false);
  try {
    var throw_error;
    var other_errors = [];
    while (current_target !== null) {
      var parent_element = current_target.assignedSlot || current_target.parentNode || /** @type {any} */
      current_target.host || null;
      try {
        var delegated = current_target["__" + event_name];
        if (delegated !== void 0 && !/** @type {any} */
        current_target.disabled) {
          if (is_array(delegated)) {
            var [fn, block2, ...data] = delegated;
            fn.apply(current_target, [event2, ...data, block2]);
          } else {
            delegated.call(current_target, event2);
          }
        }
      } catch (error) {
        if (throw_error) {
          other_errors.push(error);
        } else {
          throw_error = error;
        }
      }
      if (event2.cancelBubble || parent_element === handler_element || parent_element === null) {
        break;
      }
      current_target = parent_element;
    }
    if (throw_error) {
      for (let error of other_errors) {
        queueMicrotask(() => {
          throw error;
        });
      }
      throw throw_error;
    }
  } finally {
    set_active_block(previous_block);
    event2.__root = handler_element;
    delete event2.currentTarget;
    set_active_block(previous_block);
    set_active_reaction(previous_reaction);
    set_tracking(previous_tracking);
  }
}
function create_event(event_name, dom, handler, options = {}) {
  function target_handler(event2) {
    var previous_block = active_block;
    var previous_reaction = active_reaction;
    var previous_tracking = tracking;
    try {
      set_active_block(null);
      set_active_reaction(null);
      set_tracking(false);
      if (!options.capture) {
        handle_event_propagation.call(dom, event2);
      }
      if (!event2.cancelBubble) {
        return handler == null ? void 0 : handler.call(this, event2);
      }
    } finally {
      set_active_block(previous_block);
      set_active_reaction(previous_reaction);
      set_tracking(previous_tracking);
    }
  }
  dom.addEventListener(event_name, target_handler, options);
  return target_handler;
}
function handle_root_events(target) {
  var registered_events = /* @__PURE__ */ new Set();
  var event_handle = (events) => {
    for (var i = 0; i < events.length; i++) {
      var event_name = events[i];
      if (registered_events.has(event_name)) continue;
      registered_events.add(event_name);
      var passive = is_passive_event(event_name);
      var options = { passive };
      target.addEventListener(event_name, handle_event_propagation, options);
    }
  };
  event_handle(array_from(all_registered_events));
  root_event_handles.add(event_handle);
  return () => {
    for (var event_name of registered_events) {
      target.removeEventListener(event_name, handle_event_propagation);
    }
    root_event_handles.delete(event_handle);
  };
}

// node_modules/ripple/src/runtime/internal/client/blocks.js
function user_effect(fn) {
  if (active_block === null) {
    throw new Error(
      "effect() must be called within an active context, such as a component or effect"
    );
  }
  var component = active_component;
  if (component !== null && !component.m) {
    var e = component.e ?? (component.e = []);
    e.push({
      b: active_block,
      fn,
      r: active_reaction
    });
    return;
  }
  return block(EFFECT_BLOCK, fn);
}
function effect(fn) {
  return block(EFFECT_BLOCK, fn);
}
function render(fn, state, flags = 0) {
  return block(RENDER_BLOCK | flags, fn, state);
}
function branch(fn, flags = 0) {
  return block(BRANCH_BLOCK | flags, fn);
}
function root(fn, compat) {
  var target_fn = fn;
  if (compat != null) {
    var unmounts = [];
    for (var key in compat) {
      var api = compat[key];
      unmounts.push(api.createRoot());
    }
    target_fn = () => {
      var component_unmount = fn();
      return () => {
        component_unmount == null ? void 0 : component_unmount();
        for (var unmount of unmounts) {
          unmount == null ? void 0 : unmount();
        }
      };
    };
  }
  return block(ROOT_BLOCK, target_fn, { compat }, create_component_ctx());
}
function push_block(block2, parent_block) {
  var parent_last = parent_block.last;
  if (parent_last === null) {
    parent_block.last = parent_block.first = block2;
  } else {
    parent_last.next = block2;
    block2.prev = parent_last;
    parent_block.last = block2;
  }
}
function block(flags, fn, state = null, co) {
  var _a;
  var block2 = {
    co: co || active_component,
    d: null,
    first: null,
    f: flags,
    fn,
    last: null,
    next: null,
    p: active_block,
    prev: null,
    s: state,
    t: null
  };
  if (active_reaction !== null && (active_reaction.f & DERIVED) !== 0) {
    /** @type {Derived} */
    ((_a = active_reaction).blocks ?? (_a.blocks = [])).push(block2);
  }
  if (active_block !== null) {
    push_block(block2, active_block);
  }
  if ((flags & EFFECT_BLOCK) !== 0) {
    schedule_update(block2);
  } else {
    run_block(block2);
    block2.f ^= BLOCK_HAS_RUN;
  }
  return block2;
}
function destroy_block_children(parent, remove_dom = false) {
  var block2 = parent.first;
  parent.first = parent.last = null;
  if ((parent.f & CONTAINS_TEARDOWN) !== 0) {
    while (block2 !== null) {
      var next = block2.next;
      destroy_block(block2, remove_dom);
      block2 = next;
    }
  }
}
function destroy_non_branch_children(parent, remove_dom = false) {
  var block2 = parent.first;
  if ((parent.f & CONTAINS_TEARDOWN) === 0 && parent.first !== null && (parent.first.f & BRANCH_BLOCK) === 0) {
    parent.first = parent.last = null;
  } else {
    while (block2 !== null) {
      var next = block2.next;
      if ((block2.f & BRANCH_BLOCK) === 0) {
        destroy_block(block2, remove_dom);
      }
      block2 = next;
    }
  }
}
function unlink_block(block2) {
  var parent = block2.p;
  var prev = block2.prev;
  var next = block2.next;
  if (prev !== null) prev.next = next;
  if (next !== null) next.prev = prev;
  if (parent !== null) {
    if (parent.first === block2) parent.first = next;
    if (parent.last === block2) parent.last = prev;
  }
}
function remove_block_dom(node, end) {
  while (node !== null) {
    var next = node === end ? null : next_sibling(node);
    node.remove();
    node = next;
  }
}
function destroy_block(block2, remove_dom = true) {
  block2.f ^= DESTROYED;
  var removed = false;
  var f = block2.f;
  if (remove_dom && (f & (BRANCH_BLOCK | ROOT_BLOCK)) !== 0 || (f & HEAD_BLOCK) !== 0) {
    var s = block2.s;
    remove_block_dom(s.start, s.end);
    removed = true;
  }
  destroy_block_children(block2, remove_dom && !removed);
  run_teardown(block2);
  var parent = block2.p;
  if (parent !== null && parent.first !== null) {
    unlink_block(block2);
  }
  block2.fn = block2.s = block2.d = block2.p = block2.d = block2.co = block2.t = null;
}

// node_modules/ripple/src/runtime/internal/client/css.js
function remove_ssr_css() {
  if (!document || typeof requestAnimationFrame !== "function") {
    return;
  }
  remove_styles();
}
function remove_styles() {
  if (true_default) {
    const styles = document.querySelector("style[data-vite-dev-id]");
    if (styles) {
      remove();
    } else {
      requestAnimationFrame(remove_styles);
    }
  } else {
    remove_when_css_loaded(() => requestAnimationFrame(remove));
  }
}
function remove() {
  document.querySelectorAll("style[data-ripple-ssr]").forEach((el) => el.remove());
}
function remove_when_css_loaded(callback) {
  const links = Array.from(document.querySelectorAll('link[rel="stylesheet"]'));
  let remaining = links.length;
  if (remaining === 0) {
    callback();
    return;
  }
  const done = () => {
    remaining--;
    if (remaining === 0) {
      links.forEach((link) => {
        link.removeEventListener("load", onLoad);
        link.removeEventListener("error", onError);
      });
      callback();
    }
  };
  function onLoad() {
    done();
  }
  function onError() {
    done();
  }
  links.forEach((link) => {
    if (link.sheet) {
      done();
    } else {
      link.addEventListener("load", onLoad);
      link.addEventListener("error", onError);
    }
  });
}

// node_modules/ripple/src/jsx-runtime.js
function jsx(type, props, key) {
  if (typeof type === "function") {
    type(props);
  } else {
    console.warn("DOM element rendering not implemented in jsx runtime:", type, props);
  }
}
function jsxs(type, props, key) {
  return jsx(type, props, key);
}
function Fragment(props) {
  console.warn("Fragment rendering not implemented in jsx runtime:", props);
}

// node_modules/ripple/src/runtime/internal/client/context.js
var Context = class {
  /**
   * @param {T} initial_value
   */
  constructor(initial_value) {
    this._v = initial_value;
  }
  get() {
    const component = active_component;
    const context = this;
    if (component === null) {
      throw new Error("No active component found, cannot get context");
    }
    let current_component = component;
    while (current_component !== null) {
      const context_map = current_component.c;
      if (context_map == null ? void 0 : context_map.has(context)) {
        return context_map.get(context);
      }
      current_component = current_component.p;
    }
    return context._v;
  }
  /**
   * @template T
   * @param {T} value
   */
  set(value) {
    const component = active_component;
    const context = this;
    if (component === null) {
      throw new Error("No active component found, cannot set context");
    }
    let current_context = component.c;
    if (current_context === null) {
      current_context = component.c = /* @__PURE__ */ new Map();
    }
    current_context.set(context, value);
  }
};

// node_modules/ripple/src/runtime/proxy.js
function proxy(value, block2) {
  if (typeof value !== "object" || value === null || TRACKED_ARRAY in value || TRACKED_OBJECT in value) {
    return value;
  }
  const prototype = get_prototype_of(value);
  if (prototype !== object_prototype && prototype !== array_prototype) {
    return value;
  }
  var tracked_elements = /* @__PURE__ */ new Map();
  var is_proxied_array = is_array(value);
  var tracked_len;
  if (is_proxied_array) {
    tracked_len = tracked(value.length, block2);
    tracked_elements.set("length", tracked_len);
  }
  return new Proxy(value, {
    /**
     * @param {PropertyKey} prop
     */
    get(target, prop, receiver) {
      var _a;
      var t = tracked_elements.get(prop);
      var exists = prop in target;
      if (t === void 0 && (!exists || ((_a = get_descriptor(target, prop)) == null ? void 0 : _a.writable))) {
        t = tracked(exists ? (
          /** @type {any} */
          target[prop]
        ) : UNINITIALIZED, block2);
        tracked_elements.set(prop, t);
      }
      if (t !== void 0) {
        var v = get(t);
        return v === UNINITIALIZED ? void 0 : v;
      }
      var result = Reflect.get(target, prop, receiver);
      if (typeof result === "function") {
        if (methods_returning_arrays.has(prop)) {
          return function(...args) {
            var output = Reflect.apply(result, receiver, args);
            if (Array.isArray(output) && output !== target) {
              return array_proxy({ elements: output, block: block2, use_array: true });
            }
            return output;
          };
        }
        if (is_proxied_array && (prop === "entries" || prop === "values" || prop === "keys")) {
          receiver.length;
        }
      }
      return result;
    },
    set(target, prop, value2, receiver) {
      var _a;
      var t = tracked_elements.get(prop);
      var exists = prop in target;
      if (is_proxied_array && prop === "length" && t !== void 0) {
        for (var i = value2; i < t.__v; i += 1) {
          var other_t = tracked_elements.get(i + "");
          if (other_t !== void 0) {
            set(other_t, UNINITIALIZED);
          } else if (i in target) {
            other_t = tracked(UNINITIALIZED, block2);
            tracked_elements.set(i + "", other_t);
          }
        }
      }
      if (t === void 0) {
        if (!exists || ((_a = get_descriptor(target, prop)) == null ? void 0 : _a.writable)) {
          t = tracked(void 0, block2);
          set(t, value2);
          tracked_elements.set(prop, t);
        }
      } else {
        exists = t.__v !== UNINITIALIZED;
        set(t, value2);
      }
      var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
      if (descriptor == null ? void 0 : descriptor.set) {
        descriptor.set.call(receiver, value2);
      }
      if (!exists && is_proxied_array && typeof prop === "string") {
        var n = Number(prop);
        if (Number.isInteger(n) && n >= tracked_len.__v) {
          set(tracked_len, n + 1);
        }
      }
      return true;
    },
    setPrototypeOf() {
      throw new Error(`Cannot set prototype of ${is_proxied_array ? "`TrackedArray`" : "`TrackedObject`"}`);
    },
    deleteProperty(target, prop) {
      var t = tracked_elements.get(prop);
      if (t === void 0) {
        if (prop in target) {
          const t2 = tracked(UNINITIALIZED, block2);
          tracked_elements.set(prop, t2);
        }
      } else {
        set(t, UNINITIALIZED);
      }
      return Reflect.deleteProperty(target, prop);
    },
    has(target, prop) {
      var _a;
      if (is_proxied_array && prop === TRACKED_ARRAY) {
        return true;
      }
      if (prop === TRACKED_OBJECT) {
        return true;
      }
      var t = tracked_elements.get(prop);
      var exists = t !== void 0 && t.__v !== UNINITIALIZED || Reflect.has(target, prop);
      if (t !== void 0 || !exists || ((_a = get_descriptor(target, prop)) == null ? void 0 : _a.writable)) {
        if (t === void 0) {
          t = tracked(exists ? (
            /** @type {any} */
            target[prop]
          ) : UNINITIALIZED, block2);
          tracked_elements.set(prop, t);
        }
        var value2 = get(t);
        if (value2 === UNINITIALIZED) {
          return false;
        }
      }
      return exists;
    },
    defineProperty(_, prop, descriptor) {
      if (!("value" in descriptor) || descriptor.configurable === false || descriptor.enumerable === false || descriptor.writable === false) {
        throw new Error(
          "Only basic property descriptors are supported with value and configurable, enumerable, and writable set to true"
        );
      }
      var t = tracked_elements.get(prop);
      if (t === void 0) {
        t = tracked(descriptor.value, block2);
        tracked_elements.set(prop, t);
      } else {
        set(t, descriptor.value);
      }
      return true;
    },
    ownKeys(target) {
      var own_keys = Reflect.ownKeys(target).filter((key2) => {
        var t2 = tracked_elements.get(key2);
        return t2 === void 0 || t2.__v !== UNINITIALIZED;
      });
      for (var [key, t] of tracked_elements) {
        if (t.__v !== UNINITIALIZED && !(key in target)) {
          own_keys.push(key);
        }
      }
      return own_keys;
    },
    getOwnPropertyDescriptor(target, prop) {
      var descriptor = Reflect.getOwnPropertyDescriptor(target, prop);
      if (descriptor && "value" in descriptor) {
        var t = tracked_elements.get(prop);
        if (t) descriptor.value = get(t);
      } else if (descriptor === void 0) {
        var t = tracked_elements.get(prop);
        var value2 = t == null ? void 0 : t.__v;
        if (t !== void 0 && value2 !== UNINITIALIZED) {
          return {
            enumerable: true,
            configurable: true,
            value: value2,
            writable: true
          };
        }
      }
      return descriptor;
    }
  });
}
function array_proxy({ elements, block: block2, from_static = false, use_array = false }) {
  var arr;
  var first;
  if (from_static && (first = get_first_if_length(
    /** @type {Array<T>} */
    elements
  )) !== void 0) {
    arr = new Array();
    arr[0] = first;
  } else if (use_array) {
    arr = elements;
  } else {
    arr = new Array(...elements);
  }
  return proxy(arr, block2);
}
function object_proxy(obj, block2) {
  return proxy(obj, block2);
}
var methods_returning_arrays = /* @__PURE__ */ new Set([
  "concat",
  "filter",
  "flat",
  "flatMap",
  "map",
  "slice",
  "splice",
  "toReversed",
  "toSorted",
  "toSpliced",
  "with"
]);
function get_first_if_length(array) {
  var first = array[0];
  if (array.length === 1 && 0 in array && Number.isInteger(first) && /** @type {number} */
  first >= 0 && /** @type {number} */
  first <= MAX_ARRAY_LENGTH) {
    return (
      /** @type {number} */
      first
    );
  }
}

// node_modules/ripple/src/runtime/array.js
function TrackedArray(...elements) {
  if (!new.target) {
    throw new Error("TrackedArray must be called with 'new'");
  }
  var block2 = safe_scope();
  return array_proxy({ elements, block: block2 });
}
TrackedArray.from = function(arrayLike, mapFn, thisArg) {
  var block2 = safe_scope();
  var elements = mapFn ? Array.from(arrayLike, mapFn, thisArg) : Array.from(arrayLike);
  return array_proxy({ elements, block: block2, from_static: true });
};
TrackedArray.of = function(...items) {
  var block2 = safe_scope();
  var elements = Array.of(...items);
  return array_proxy({ elements, block: block2, from_static: true });
};
TrackedArray.fromAsync = async function(arrayLike, mapFn, thisArg) {
  var block2 = safe_scope();
  var elements = mapFn ? await Array.fromAsync(arrayLike, mapFn, thisArg) : await Array.fromAsync(arrayLike);
  return array_proxy({ elements, block: block2, from_static: true });
};

// node_modules/ripple/src/runtime/object.js
function TrackedObject(obj) {
  if (!new.target) {
    throw new Error("TrackedObject must be called with 'new'");
  }
  var block2 = safe_scope();
  return object_proxy(obj, block2);
}

// node_modules/ripple/src/runtime/set.js
var introspect_methods = ["entries", "forEach", "keys", "values", Symbol.iterator];
var compare_other_methods = ["isDisjointFrom", "isSubsetOf", "isSupersetOf"];
var new_other_methods = ["difference", "intersection", "symmetricDifference", "union"];
var init = false;
var _tracked_size, _tracked_items, _block, _TrackedSet_instances, init_fn;
var _TrackedSet = class _TrackedSet extends Set {
  /**
   * @param {Iterable<T>} [iterable]
   */
  constructor(iterable) {
    super();
    __privateAdd(this, _TrackedSet_instances);
    /** @type {Tracked} */
    __privateAdd(this, _tracked_size);
    /** @type {Map<T, Tracked>} */
    __privateAdd(this, _tracked_items, /* @__PURE__ */ new Map());
    /** @type {Block} */
    __privateAdd(this, _block);
    var block2 = __privateSet(this, _block, safe_scope());
    if (iterable) {
      for (var item of iterable) {
        super.add(item);
        __privateGet(this, _tracked_items).set(item, tracked(0, block2));
      }
    }
    __privateSet(this, _tracked_size, tracked(super.size, block2));
    if (!init) {
      init = true;
      __privateMethod(this, _TrackedSet_instances, init_fn).call(this);
    }
  }
  /**
   * @param {T} value
   * @returns {this}
   */
  add(value) {
    var block2 = __privateGet(this, _block);
    if (!super.has(value)) {
      super.add(value);
      __privateGet(this, _tracked_items).set(value, tracked(0, block2));
      set(__privateGet(this, _tracked_size), super.size);
    }
    return this;
  }
  /**
   * @param {T} value
   * @returns {boolean}
   */
  delete(value) {
    var block2 = __privateGet(this, _block);
    if (!super.delete(value)) {
      return false;
    }
    var t = __privateGet(this, _tracked_items).get(value);
    if (t) {
      increment(t);
    }
    __privateGet(this, _tracked_items).delete(value);
    set(__privateGet(this, _tracked_size), super.size);
    return true;
  }
  /**
   * @param {T} value
   * @return {boolean}
  */
  has(value) {
    var has = super.has(value);
    var tracked_items = __privateGet(this, _tracked_items);
    var t = tracked_items.get(value);
    if (t === void 0) {
      this.size;
    } else {
      get(t);
    }
    return has;
  }
  /**
   * @returns {void}
   */
  clear() {
    var block2 = __privateGet(this, _block);
    if (super.size === 0) {
      return;
    }
    for (var [_, t] of __privateGet(this, _tracked_items)) {
      increment(t);
    }
    super.clear();
    __privateGet(this, _tracked_items).clear();
    set(__privateGet(this, _tracked_size), 0);
  }
  /**
   * @returns {number}
   */
  get size() {
    return get(__privateGet(this, _tracked_size));
  }
  /**
   * @returns {T[]}
   */
  toJSON() {
    this.size;
    return [...this];
  }
};
_tracked_size = new WeakMap();
_tracked_items = new WeakMap();
_block = new WeakMap();
_TrackedSet_instances = new WeakSet();
/**
 * @returns {void}
 */
init_fn = function() {
  var proto = _TrackedSet.prototype;
  var set_proto = Set.prototype;
  for (const method of introspect_methods) {
    if (!(method in set_proto)) {
      continue;
    }
    proto[method] = function(...v) {
      this.size;
      return (
        /** @type {any} */
        set_proto[method].apply(this, v)
      );
    };
  }
  for (const method of compare_other_methods) {
    if (!(method in set_proto)) {
      continue;
    }
    proto[method] = function(other, ...v) {
      this.size;
      if (other instanceof _TrackedSet) {
        other.size;
      }
      return (
        /** @type {any} */
        set_proto[method].apply(this, [other, ...v])
      );
    };
  }
  for (const method of new_other_methods) {
    if (!(method in set_proto)) {
      continue;
    }
    proto[method] = function(other, ...v) {
      this.size;
      if (other instanceof _TrackedSet) {
        other.size;
      }
      return new _TrackedSet(
        /** @type {any} */
        set_proto[method].apply(this, [other, ...v])
      );
    };
  }
};
var TrackedSet = _TrackedSet;

// node_modules/ripple/src/runtime/map.js
var introspect_methods2 = ["entries", "forEach", "values", Symbol.iterator];
var init2 = false;
var _tracked_size2, _tracked_items2, _block2, _TrackedMap_instances, init_fn2, read_all_fn;
var _TrackedMap = class _TrackedMap extends Map {
  /**
   * @param {Iterable<readonly [K, V]>} [iterable]
   */
  constructor(iterable) {
    super();
    __privateAdd(this, _TrackedMap_instances);
    /** @type {Tracked} */
    __privateAdd(this, _tracked_size2);
    /** @type {Map<K, Tracked>} */
    __privateAdd(this, _tracked_items2, /* @__PURE__ */ new Map());
    /** @type {Block} */
    __privateAdd(this, _block2);
    var block2 = __privateSet(this, _block2, safe_scope());
    if (iterable) {
      for (var [key, value] of iterable) {
        super.set(key, value);
        __privateGet(this, _tracked_items2).set(key, tracked(0, block2));
      }
    }
    __privateSet(this, _tracked_size2, tracked(super.size, block2));
    if (!init2) {
      init2 = true;
      __privateMethod(this, _TrackedMap_instances, init_fn2).call(this);
    }
  }
  /**
   * @param {K} key
   * @returns {V | undefined}
   */
  get(key) {
    var tracked_items = __privateGet(this, _tracked_items2);
    var t = tracked_items.get(key);
    if (t === void 0) {
      this.size;
    } else {
      get(t);
    }
    return super.get(key);
  }
  /**
   * @param {K} key
   * @returns {boolean}
   */
  has(key) {
    var has = super.has(key);
    var tracked_items = __privateGet(this, _tracked_items2);
    var t = tracked_items.get(key);
    if (t === void 0) {
      this.size;
    } else {
      get(t);
    }
    return has;
  }
  /**
   * @param {K} key
   * @param {V} value
   * @returns {this}
   */
  set(key, value) {
    var block2 = __privateGet(this, _block2);
    var tracked_items = __privateGet(this, _tracked_items2);
    var t = tracked_items.get(key);
    var prev_res = super.get(key);
    super.set(key, value);
    if (!t) {
      tracked_items.set(key, tracked(0, block2));
      set(__privateGet(this, _tracked_size2), super.size);
    } else if (prev_res !== value) {
      increment(t);
    }
    return this;
  }
  /**
   * @param {K} key
   * @returns {boolean}
   */
  delete(key) {
    var block2 = __privateGet(this, _block2);
    var tracked_items = __privateGet(this, _tracked_items2);
    var t = tracked_items.get(key);
    var result = super.delete(key);
    if (t) {
      increment(t);
      tracked_items.delete(key);
      set(__privateGet(this, _tracked_size2), super.size);
    }
    return result;
  }
  /**
   * @returns {void}
   */
  clear() {
    var block2 = __privateGet(this, _block2);
    if (super.size === 0) {
      return;
    }
    for (var [_, t] of __privateGet(this, _tracked_items2)) {
      increment(t);
    }
    super.clear();
    __privateGet(this, _tracked_items2).clear();
    set(__privateGet(this, _tracked_size2), 0);
  }
  /**
   * @returns {MapIterator<K>}
   */
  keys() {
    this.size;
    return super.keys();
  }
  /**
   * @returns {number}
   */
  get size() {
    return get(__privateGet(this, _tracked_size2));
  }
  /**
   * @returns {Array<[K, V]>}
   */
  toJSON() {
    this.size;
    __privateMethod(this, _TrackedMap_instances, read_all_fn).call(this);
    return [...this];
  }
};
_tracked_size2 = new WeakMap();
_tracked_items2 = new WeakMap();
_block2 = new WeakMap();
_TrackedMap_instances = new WeakSet();
/**
 * @returns {void}
 */
init_fn2 = function() {
  var proto = _TrackedMap.prototype;
  var map_proto = Map.prototype;
  for (const method of introspect_methods2) {
    proto[method] = function(...v) {
      this.size;
      __privateMethod(this, _TrackedMap_instances, read_all_fn).call(this);
      return (
        /** @type {any} */
        map_proto[method].apply(this, v)
      );
    };
  }
};
/**
 * @returns {void}
 */
read_all_fn = function() {
  for (const [, t] of __privateGet(this, _tracked_items2)) {
    get(t);
  }
};
var TrackedMap = _TrackedMap;

// node_modules/ripple/src/runtime/date.js
var init3 = false;
var _time, _deriveds, _block3, _TrackedDate_instances, init_fn3;
var _TrackedDate = class _TrackedDate extends Date {
  /** @param {any[]} params */
  constructor(...params) {
    super(...params);
    __privateAdd(this, _TrackedDate_instances);
    __privateAdd(this, _time);
    /** @type {Map<keyof Date, Derived>} */
    __privateAdd(this, _deriveds, /* @__PURE__ */ new Map());
    /** @type {Block} */
    __privateAdd(this, _block3);
    var block2 = __privateSet(this, _block3, safe_scope());
    __privateSet(this, _time, tracked(super.getTime(), block2));
    if (!init3) __privateMethod(this, _TrackedDate_instances, init_fn3).call(this);
  }
};
_time = new WeakMap();
_deriveds = new WeakMap();
_block3 = new WeakMap();
_TrackedDate_instances = new WeakSet();
init_fn3 = function() {
  init3 = true;
  var proto = _TrackedDate.prototype;
  var date_proto = Date.prototype;
  var methods = (
    /** @type {Array<keyof Date & string>} */
    Object.getOwnPropertyNames(date_proto)
  );
  for (const method of methods) {
    if (method.startsWith("get") || method.startsWith("to") || method === "valueOf") {
      proto[method] = function(...args) {
        if (args.length > 0) {
          get(__privateGet(this, _time));
          return date_proto[method].apply(this, args);
        }
        var d = __privateGet(this, _deriveds).get(method);
        if (d === void 0) {
          d = derived(() => {
            get(__privateGet(this, _time));
            return date_proto[method].apply(this, args);
          }, __privateGet(this, _block3));
          __privateGet(this, _deriveds).set(method, d);
        }
        return get(d);
      };
    }
    if (method.startsWith("set")) {
      proto[method] = function(...args) {
        var result = date_proto[method].apply(this, args);
        set(__privateGet(this, _time), date_proto.getTime.call(this));
        return result;
      };
    }
  }
};
var TrackedDate = _TrackedDate;

// node_modules/ripple/src/runtime/url-search-params.js
var REPLACE = Symbol();
var _block4, _version, _url, _updating, _TrackedURLSearchParams_instances, update_url_fn;
var TrackedURLSearchParams = class extends URLSearchParams {
  constructor() {
    super(...arguments);
    __privateAdd(this, _TrackedURLSearchParams_instances);
    __privateAdd(this, _block4, safe_scope());
    __privateAdd(this, _version, tracked(0, __privateGet(this, _block4)));
    __privateAdd(this, _url, get_current_url());
    __privateAdd(this, _updating, false);
  }
  /**
   * @param {URLSearchParams} params
   * @internal
   */
  [REPLACE](params) {
    if (__privateGet(this, _updating)) return;
    __privateSet(this, _updating, true);
    for (const key of [...super.keys()]) {
      super.delete(key);
    }
    for (const [key, value] of params) {
      super.append(key, value);
    }
    increment(__privateGet(this, _version));
    __privateSet(this, _updating, false);
  }
  /**
   * @param {string} name
   * @param {string} value
   * @returns {void}
   */
  append(name, value) {
    super.append(name, value);
    __privateMethod(this, _TrackedURLSearchParams_instances, update_url_fn).call(this);
    increment(__privateGet(this, _version));
  }
  /**
   * @param {string} name
   * @param {string=} value
   * @returns {void}
   */
  delete(name, value) {
    var has_value = super.has(name, value);
    super.delete(name, value);
    if (has_value) {
      __privateMethod(this, _TrackedURLSearchParams_instances, update_url_fn).call(this);
      increment(__privateGet(this, _version));
    }
  }
  /**
   * @param {string} name
   * @returns {string|null}
   */
  get(name) {
    get(__privateGet(this, _version));
    return super.get(name);
  }
  /**
   * @param {string} name
   * @returns {string[]}
   */
  getAll(name) {
    get(__privateGet(this, _version));
    return super.getAll(name);
  }
  /**
   * @param {string} name
   * @param {string=} value
   * @returns {boolean}
   */
  has(name, value) {
    get(__privateGet(this, _version));
    return super.has(name, value);
  }
  keys() {
    get(__privateGet(this, _version));
    return super.keys();
  }
  /**
   * @param {string} name
   * @param {string} value
   * @returns {void}
   */
  set(name, value) {
    var previous = super.getAll(name).join("");
    super.set(name, value);
    if (previous !== super.getAll(name).join("")) {
      __privateMethod(this, _TrackedURLSearchParams_instances, update_url_fn).call(this);
      increment(__privateGet(this, _version));
    }
  }
  sort() {
    super.sort();
    __privateMethod(this, _TrackedURLSearchParams_instances, update_url_fn).call(this);
    increment(__privateGet(this, _version));
  }
  toString() {
    get(__privateGet(this, _version));
    return super.toString();
  }
  values() {
    get(__privateGet(this, _version));
    return super.values();
  }
  entries() {
    get(__privateGet(this, _version));
    return super.entries();
  }
  [Symbol.iterator]() {
    return this.entries();
  }
  get size() {
    get(__privateGet(this, _version));
    return super.size;
  }
};
_block4 = new WeakMap();
_version = new WeakMap();
_url = new WeakMap();
_updating = new WeakMap();
_TrackedURLSearchParams_instances = new WeakSet();
update_url_fn = function() {
  if (!__privateGet(this, _url) || __privateGet(this, _updating)) return;
  __privateSet(this, _updating, true);
  const search = this.toString();
  __privateGet(this, _url).search = search && `?${search}`;
  __privateSet(this, _updating, false);
};

// node_modules/ripple/src/runtime/url.js
var current_url = null;
function get_current_url() {
  return current_url;
}
var _block5, _protocol, _username, _password, _hostname, _port, _pathname, _hash, _search, _searchParams;
var TrackedURL = class extends URL {
  /**
   * @param {string | URL} url
   * @param {string | URL} [base]
   */
  constructor(url, base) {
    url = new URL(url, base);
    super(url);
    __privateAdd(this, _block5, safe_scope());
    __privateAdd(this, _protocol, tracked(super.protocol, __privateGet(this, _block5)));
    __privateAdd(this, _username, tracked(super.username, __privateGet(this, _block5)));
    __privateAdd(this, _password, tracked(super.password, __privateGet(this, _block5)));
    __privateAdd(this, _hostname, tracked(super.hostname, __privateGet(this, _block5)));
    __privateAdd(this, _port, tracked(super.port, __privateGet(this, _block5)));
    __privateAdd(this, _pathname, tracked(super.pathname, __privateGet(this, _block5)));
    __privateAdd(this, _hash, tracked(super.hash, __privateGet(this, _block5)));
    __privateAdd(this, _search, tracked(super.search, __privateGet(this, _block5)));
    __privateAdd(this, _searchParams);
    current_url = this;
    __privateSet(this, _searchParams, new TrackedURLSearchParams(url.searchParams));
    current_url = null;
  }
  get hash() {
    return get(__privateGet(this, _hash));
  }
  set hash(value) {
    super.hash = value;
    set(__privateGet(this, _hash), super.hash);
  }
  get host() {
    get(__privateGet(this, _hostname));
    get(__privateGet(this, _port));
    return super.host;
  }
  set host(value) {
    super.host = value;
    set(__privateGet(this, _hostname), super.hostname);
    set(__privateGet(this, _port), super.port);
  }
  get hostname() {
    return get(__privateGet(this, _hostname));
  }
  set hostname(value) {
    super.hostname = value;
    set(__privateGet(this, _hostname), super.hostname);
  }
  get href() {
    get(__privateGet(this, _protocol));
    get(__privateGet(this, _username));
    get(__privateGet(this, _password));
    get(__privateGet(this, _hostname));
    get(__privateGet(this, _port));
    get(__privateGet(this, _pathname));
    get(__privateGet(this, _hash));
    get(__privateGet(this, _search));
    return super.href;
  }
  set href(value) {
    super.href = value;
    set(__privateGet(this, _protocol), super.protocol);
    set(__privateGet(this, _username), super.username);
    set(__privateGet(this, _password), super.password);
    set(__privateGet(this, _hostname), super.hostname);
    set(__privateGet(this, _port), super.port);
    set(__privateGet(this, _pathname), super.pathname);
    set(__privateGet(this, _hash), super.hash);
    set(__privateGet(this, _search), super.search);
    __privateGet(this, _searchParams)[REPLACE](super.searchParams);
  }
  get password() {
    return get(__privateGet(this, _password));
  }
  set password(value) {
    super.password = value;
    set(__privateGet(this, _password), super.password);
  }
  get pathname() {
    return get(__privateGet(this, _pathname));
  }
  set pathname(value) {
    super.pathname = value;
    set(__privateGet(this, _pathname), super.pathname);
  }
  get port() {
    return get(__privateGet(this, _port));
  }
  set port(value) {
    super.port = value;
    set(__privateGet(this, _port), super.port);
  }
  get protocol() {
    return get(__privateGet(this, _protocol));
  }
  set protocol(value) {
    super.protocol = value;
    set(__privateGet(this, _protocol), super.protocol);
  }
  get search() {
    return get(__privateGet(this, _search));
  }
  set search(value) {
    super.search = value;
    set(__privateGet(this, _search), value);
    __privateGet(this, _searchParams)[REPLACE](super.searchParams);
  }
  get username() {
    return get(__privateGet(this, _username));
  }
  set username(value) {
    super.username = value;
    set(__privateGet(this, _username), super.username);
  }
  get origin() {
    get(__privateGet(this, _protocol));
    get(__privateGet(this, _hostname));
    get(__privateGet(this, _port));
    return super.origin;
  }
  get searchParams() {
    return __privateGet(this, _searchParams);
  }
  toString() {
    return this.href;
  }
  toJSON() {
    return this.href;
  }
};
_block5 = new WeakMap();
_protocol = new WeakMap();
_username = new WeakMap();
_password = new WeakMap();
_hostname = new WeakMap();
_port = new WeakMap();
_pathname = new WeakMap();
_hash = new WeakMap();
_search = new WeakMap();
_searchParams = new WeakMap();

// node_modules/ripple/src/runtime/create-subscriber.js
function createSubscriber(start) {
  let subscribers = 0;
  let stop;
  return () => {
    effect(() => {
      if (subscribers === 0) {
        stop = untrack(start);
      }
      subscribers += 1;
      return () => {
        queue_microtask(() => {
          subscribers -= 1;
          if (subscribers === 0) {
            stop == null ? void 0 : stop();
            stop = void 0;
          }
        });
      };
    });
  };
}

// node_modules/ripple/src/constants.js
var TEMPLATE_USE_IMPORT_NODE = 1 << 1;
var IS_CONTROLLED = 1 << 2;
var IS_INDEXED = 1 << 3;
var TEMPLATE_SVG_NAMESPACE = 1 << 5;
var TEMPLATE_MATHML_NAMESPACE = 1 << 6;

// node_modules/devalue/src/utils.js
var object_proto_names = Object.getOwnPropertyNames(
  Object.prototype
).sort().join("\0");

// node_modules/ripple/src/runtime/reactive-value.js
function ReactiveValue(fn, start) {
  if (!new.target) {
    throw new TypeError("`ReactiveValue` must be called with new");
  }
  const s = createSubscriber(start);
  const block2 = safe_scope();
  return derived(fn, block2, () => {
    s();
    return fn();
  }, (_, prev) => prev);
}

// node_modules/ripple/src/runtime/media-query.js
var parenthesis_regex = /\(.+\)/;
var non_parenthesized_keywords = /* @__PURE__ */ new Set(["all", "print", "screen", "and", "or", "not", "only"]);
function MediaQuery(query, fallback2) {
  if (!new.target) {
    throw new TypeError("MediaQuery must be called with new");
  }
  var block2 = safe_scope();
  let final_query = parenthesis_regex.test(query) || // we need to use `some` here because technically this `window.matchMedia('random,screen')` still returns true
  query.split(/[\s,]+/).some((keyword) => non_parenthesized_keywords.has(keyword.trim())) ? query : `(${query})`;
  const q = window.matchMedia(final_query);
  const matches = tracked(q.matches, block2);
  return new ReactiveValue(
    () => get(matches),
    () => on(q, "change", () => {
      if (q.matches !== get(matches)) {
        set(matches, q.matches);
      }
    })
  );
}

// node_modules/ripple/src/runtime/internal/client/portal.js
function Portal(_, props) {
  let target = UNINITIALIZED;
  let children = UNINITIALIZED;
  var b = null;
  var anchor = null;
  var dom_start = null;
  var dom_end = null;
  render(() => {
    var _a, _b;
    if (target === (target = props.target)) return;
    if (children === (children = props.children)) return;
    if (b !== null) {
      destroy_block(b);
    }
    if (anchor !== null) {
      anchor.remove();
    }
    dom_start = dom_end = null;
    anchor = create_text();
    target.append(anchor);
    const cleanup_events = handle_root_events(
      /** @type {Element} */
      target
    );
    var block2 = (
      /** @type {Block} */
      active_block
    );
    b = branch(() => {
      if (typeof children === "function") {
        children(
          /** @type {Text} */
          anchor,
          {},
          block2
        );
      }
    });
    dom_start = (_a = b == null ? void 0 : b.s) == null ? void 0 : _a.start;
    dom_end = (_b = b == null ? void 0 : b.s) == null ? void 0 : _b.end;
    return () => {
      cleanup_events();
      anchor.remove();
      if (dom_start && dom_end) {
        remove_block_dom(dom_start, dom_end);
      }
    };
  });
}

// node_modules/ripple/src/runtime/internal/client/bindings.js
function not_tracked_type_error(name) {
  return new TypeError(`${name} argument is not a tracked object`);
}
var _listeners, _observer, _options, _ResizeObserverSingleton_instances, getObserver_fn;
var _ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    __privateAdd(this, _ResizeObserverSingleton_instances);
    /** */
    __privateAdd(this, _listeners, /* @__PURE__ */ new WeakMap());
    /** @type {ResizeObserver | undefined} */
    __privateAdd(this, _observer);
    /** @type {ResizeObserverOptions} */
    __privateAdd(this, _options);
    __privateSet(this, _options, options);
  }
  /**
   * @param {Element} element
   * @param {(entry: ResizeObserverEntry) => any} listener
   */
  observe(element, listener) {
    var listeners = __privateGet(this, _listeners).get(element) || /* @__PURE__ */ new Set();
    listeners.add(listener);
    __privateGet(this, _listeners).set(element, listeners);
    __privateMethod(this, _ResizeObserverSingleton_instances, getObserver_fn).call(this).observe(element, __privateGet(this, _options));
    return () => {
      var listeners2 = __privateGet(this, _listeners).get(element);
      listeners2.delete(listener);
      if (listeners2.size === 0) {
        __privateGet(this, _listeners).delete(element);
        __privateGet(this, _observer).unobserve(element);
      }
    };
  }
};
_listeners = new WeakMap();
_observer = new WeakMap();
_options = new WeakMap();
_ResizeObserverSingleton_instances = new WeakSet();
getObserver_fn = function() {
  return __privateGet(this, _observer) ?? __privateSet(this, _observer, new ResizeObserver(
    /** @param {any} entries */
    (entries) => {
      for (var entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        for (var listener of __privateGet(this, _listeners).get(entry.target) || []) {
          listener(entry);
        }
      }
    }
  ));
};
/** @static */
__publicField(_ResizeObserverSingleton, "entries", /* @__PURE__ */ new WeakMap());
var ResizeObserverSingleton = _ResizeObserverSingleton;
var resize_observer_content_box = new ResizeObserverSingleton({
  box: "content-box"
});
var resize_observer_border_box = new ResizeObserverSingleton({
  box: "border-box"
});
var resize_observer_device_pixel_content_box = new ResizeObserverSingleton({
  box: "device-pixel-content-box"
});
function to_number(value) {
  return value === "" ? null : +value;
}
function is_numberlike_input(input) {
  var type = input.type;
  return type === "number" || type === "range";
}
function get_option_value(option) {
  return option.value;
}
function select_option(select, value, mounting = false) {
  if (select.multiple) {
    if (value == void 0) {
      return;
    }
    if (!is_array(value)) {
    }
    for (var option of select.options) {
      option.selected = /** @type {string[]} */
      value.includes(get_option_value(option));
    }
    return;
  }
  for (option of select.options) {
    var option_value = get_option_value(option);
    if (option_value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function bindValue(maybe_tracked2) {
  if (!is_tracked_object(maybe_tracked2)) {
    throw not_tracked_type_error("bindValue()");
  }
  var tracked2 = (
    /** @type {Tracked} */
    maybe_tracked2
  );
  return (node) => {
    var clear_event;
    if (node.tagName === "SELECT") {
      var select = (
        /** @type {HTMLSelectElement} */
        node
      );
      var mounting = true;
      clear_event = on(select, "change", async () => {
        var query = ":checked";
        var value;
        if (select.multiple) {
          value = [].map.call(select.querySelectorAll(query), get_option_value);
        } else {
          var selected_option = select.querySelector(query) ?? // will fall back to first non-disabled option if no option is selected
          select.querySelector("option:not([disabled])");
          value = selected_option && get_option_value(selected_option);
        }
        set(tracked2, value);
      });
      effect(() => {
        var value = get(tracked2);
        select_option(select, value, mounting);
        if (mounting && value === void 0) {
          var selected_option = select.querySelector(":checked");
          if (selected_option !== null) {
            value = get_option_value(selected_option);
            set(tracked2, value);
          }
        }
        mounting = false;
      });
    } else {
      var input = (
        /** @type {HTMLInputElement} */
        node
      );
      clear_event = on(input, "input", async () => {
        var value = input.value;
        value = is_numberlike_input(input) ? to_number(value) : value;
        set(tracked2, value);
        await tick();
        if (value !== (value = get(tracked2))) {
          var start = input.selectionStart;
          var end = input.selectionEnd;
          input.value = value ?? "";
          if (end !== null) {
            input.selectionStart = start;
            input.selectionEnd = Math.min(end, input.value.length);
          }
        }
      });
      render(() => {
        var value = get(tracked2);
        if (is_numberlike_input(input) && value === to_number(input.value)) {
          return;
        }
        if (input.type === "date" && !value && !input.value) {
          return;
        }
        if (value !== input.value) {
          input.value = value ?? "";
        }
      });
      return clear_event;
    }
  };
}
function bindChecked(maybe_tracked2) {
  if (!is_tracked_object(maybe_tracked2)) {
    throw not_tracked_type_error("bindChecked()");
  }
  const tracked2 = (
    /** @type {Tracked} */
    maybe_tracked2
  );
  return (input) => {
    const clear_event = on(input, "change", () => {
      set(tracked2, input.checked);
    });
    return clear_event;
  };
}
function bind_element_size(maybe_tracked2, type) {
  if (!is_tracked_object(maybe_tracked2)) {
    throw not_tracked_type_error(`bind${type.charAt(0).toUpperCase() + type.slice(1)}()`);
  }
  var tracked2 = (
    /** @type {Tracked<any>} */
    maybe_tracked2
  );
  return (element) => {
    var unsubscribe = resize_observer_border_box.observe(
      element,
      () => set(tracked2, element[type])
    );
    effect(() => {
      untrack(() => set(tracked2, element[type]));
      return unsubscribe;
    });
  };
}
function bindClientWidth(maybe_tracked2) {
  return bind_element_size(maybe_tracked2, "clientWidth");
}
function bindClientHeight(maybe_tracked2) {
  return bind_element_size(maybe_tracked2, "clientHeight");
}
function bind_element_rect(maybe_tracked2, type) {
  if (!is_tracked_object(maybe_tracked2)) {
    throw not_tracked_type_error(`bind${type.charAt(0).toUpperCase() + type.slice(1)}()`);
  }
  var tracked2 = (
    /** @type {Tracked<any>} */
    maybe_tracked2
  );
  var observer = type === "contentRect" || type === "contentBoxSize" ? resize_observer_content_box : type === "borderBoxSize" ? resize_observer_border_box : resize_observer_device_pixel_content_box;
  return (element) => {
    var unsubscribe = observer.observe(
      element,
      /** @param {any} entry */
      (entry) => set(tracked2, entry[type])
    );
    effect(() => unsubscribe);
  };
}
function bindContentRect(maybe_tracked2) {
  return bind_element_rect(maybe_tracked2, "contentRect");
}
function bindContentBoxSize(maybe_tracked2) {
  return bind_element_rect(maybe_tracked2, "contentBoxSize");
}
function bindBorderBoxSize(maybe_tracked2) {
  return bind_element_rect(maybe_tracked2, "borderBoxSize");
}
function bindDevicePixelContentBoxSize(maybe_tracked2) {
  return bind_element_rect(maybe_tracked2, "devicePixelContentBoxSize");
}
function bind_content_editable(maybe_tracked2, property) {
  if (!is_tracked_object(maybe_tracked2)) {
    throw not_tracked_type_error(`bind${property.charAt(0).toUpperCase() + property.slice(1)}()`);
  }
  const tracked2 = (
    /** @type {Tracked} */
    maybe_tracked2
  );
  return (element) => {
    const clear_event = on(element, "input", () => {
      set(tracked2, element[property]);
    });
    render(() => {
      var value = get(tracked2);
      if (element[property] !== value) {
        if (value == null) {
          var non_null_value = element[property];
          set(tracked2, non_null_value);
        } else {
          element[property] = value + "";
        }
      }
    });
    return clear_event;
  };
}
function bindInnerHTML(maybe_tracked2) {
  return bind_content_editable(maybe_tracked2, "innerHTML");
}
function bindInnerText(maybe_tracked2) {
  return bind_content_editable(maybe_tracked2, "innerText");
}
function bindTextContent(maybe_tracked2) {
  return bind_content_editable(maybe_tracked2, "textContent");
}
function bindNode(maybe_tracked2) {
  if (!is_tracked_object(maybe_tracked2)) {
    throw not_tracked_type_error("bindNode()");
  }
  const tracked2 = (
    /** @type {Tracked} */
    maybe_tracked2
  );
  return (node) => {
    set(tracked2, node);
  };
}

// node_modules/ripple/src/runtime/index-client.js
function mount(component, options) {
  init_operations();
  remove_ssr_css();
  const props = options.props || {};
  const target = options.target;
  const anchor = create_anchor();
  if (target.firstChild) {
    target.textContent = "";
  }
  target.append(anchor);
  const cleanup_events = handle_root_events(target);
  const _root = root(() => {
    component(anchor, props, active_block);
  }, options.compat);
  return () => {
    cleanup_events();
    destroy_block(_root);
  };
}
export {
  Context,
  Fragment,
  MediaQuery,
  Portal,
  TrackedArray,
  TrackedDate,
  TrackedMap,
  TrackedObject,
  TrackedSet,
  TrackedURL,
  TrackedURLSearchParams,
  bindBorderBoxSize,
  bindChecked,
  bindClientHeight,
  bindClientWidth,
  bindContentBoxSize,
  bindContentRect,
  bindDevicePixelContentBoxSize,
  bindInnerHTML,
  bindInnerText,
  bindNode,
  bindTextContent,
  bindValue,
  ref_prop as createRefKey,
  createSubscriber,
  user_effect as effect,
  flush_sync as flushSync,
  get,
  jsx,
  jsxs,
  mount,
  on,
  public_set as set,
  tick,
  track,
  track_split as trackSplit,
  untrack
};
//# sourceMappingURL=ripple.js.map
